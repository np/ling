layout toplevel ;
layout "of" ;

comment "--" ;
comment "{-" "-}" ;

Prg. Program ::= [Dec] ;

token Name ((letter | ["_-+*/%"] | digit)*
            (letter | ["_-+*/%"])
            (letter | ["_-+*/%'"] | digit)*) ;

separator Name "" ;

DDef. Dec ::= Name OptSig "=" Term ;
DSig. Dec ::= Name ":" Term ;
DDat. Dec ::= "data" Name "=" [ConName] ;

DAsr. Dec ::= "assert" Assertion ;

AEq. Assertion ::= Term "=" Term OptSig ;

CN. ConName ::= "`" Name ;

separator ConName "|" ;

NoSig. OptSig ::= ;
SoSig. OptSig ::= ":" Term ;

separator Dec "," ;

VD. VarDec ::= "(" Name OptSig ")" ;

CD. ChanDec ::= Name OptSession ;

separator ChanDec "," ;

Br. Branch ::= ConName "->" Term ;

separator Branch "," ;

LInteger. Literal ::= Integer ;
LDouble.  Literal ::= Double  ;
LString.  Literal ::= String  ;
LChar.    Literal ::= Char    ;

-- Atomic terms
Var.     ATerm ::= Name ;
Lit.     ATerm ::= Literal ;
Con.     ATerm ::= ConName ;
TTyp.    ATerm ::= "Type" ;
TProto.  ATerm ::= "<" [RSession] ">" ;
Paren.   ATerm ::= "(" Term OptSig ")" ;

-- Sessions
End.     ATerm ::= "end" ;
Par.     ATerm ::= "{"  [RSession]  "}" ;
Ten.     ATerm ::= "["  [RSession]  "]" ;
Seq.     ATerm ::= "[:" [RSession] ":]" ;

separator ATerm "" ;

RawApp.   Term3  ::= ATerm [ATerm] ;

Case.     Term2  ::= "case" Term "of" "{" [Branch] "}" ;
Snd.      Term2  ::= "!" Term3 CSession ;
Rcv.      Term2  ::= "?" Term3 CSession ;
Dual.     Term2  ::= "~" Term2 ;
_.        Term2  ::= Term3 ;

Loli.     Term1  ::= Term2 "-o" Term1 ;
-- WARNING: Dependent `->`/`**` (e.g. Π/Σ) are recognized afterwards.
-- Notice that `Term2` is used on the left of `->` and `**`.
-- In Ling.Reify this `Term2` is analysed:
-- If it matches against `("(" Name [Name] ":" Term ")")+` then this is a
-- dependent (`->`/`**`).
-- Otherwise it is considered as a *non* dependent `->`/`**`.
-- For instance `(Vec Int n : Type)-> F Vec Int n` is a dependent `->`
-- which introduces 3 types `Vec`, `Int`, and `n`, while
-- `(Vec Int 42 : Type)-> T` is single non-dependent `->` where `: Type` is
-- an annotation.
TFun.     Term1  ::= Term2 "->" Term1 ;
TSig.     Term1  ::= Term2 "**" Term1 ;
Let.      Term1  ::= "let" Name OptSig "=" Term "in" Term ;
_.        Term1  ::= Term2 ;

-- WARNING: The `Term2` is further analysed as: `("(" Name [Name] ":" Term ")")+`
Lam.      Term   ::= "\\" Term2 "->" Term ;
TProc.    Term   ::= "proc" "(" [ChanDec] ")" Proc ;
_.        Term   ::= Term1 ;

PAct.     Proc1 ::= Act ;
PPrll.    Proc1 ::= "(" [Proc] ")" ;

PNxt.     Proc ::= Proc1 Proc ;
PDot.     Proc ::= Proc1 "." Proc ;
NewSlice. Proc ::= "slice" "(" [ChanDec] ")" ATerm "as" Name Proc ;
_.        Proc ::= Proc1 ;
separator Proc "|" ;

Nu.       Act ::= "new" "(" [ChanDec] ")" ;
ParSplit. Act ::= Name "{" [ChanDec] "}" ;
TenSplit. Act ::= Name "[" [ChanDec] "]" ;
SeqSplit. Act ::= Name "[:" [ChanDec] ":]" ;
Send.     Act ::= "send" Name ATerm ;
Recv.     Act ::= "recv" Name VarDec ;
Ax.       Act ::= "fwd" ASession "(" [ChanDec] ")" ;
SplitAx.  Act ::= "fwd" Integer ASession Name ;
At.       Act ::= "@" ATerm TopCPatt ;
LetA.     Act ::= "let" Name OptSig "=" ATerm ;

AS.       ASession ::= ATerm ;

OldTopPatt. TopCPatt ::= "(" [ChanDec] ")" ;
ParTopPatt. TopCPatt ::= "{"  [CPatt]  "}" ;
TenTopPatt. TopCPatt ::= "["  [CPatt]  "]" ;
SeqTopPatt. TopCPatt ::= "[:" [CPatt] ":]" ;

ChaPatt.  CPatt ::= ChanDec ;
ParPatt.  CPatt ::= "{"  [CPatt]  "}" ;
TenPatt.  CPatt ::= "["  [CPatt]  "]" ;
SeqPatt.  CPatt ::= "[:" [CPatt] ":]" ;

separator CPatt "," ;

NoSession. OptSession ::= ;
SoSession. OptSession ::= ":" RSession ;

Repl. RSession ::= Term OptRepl ;
separator RSession "," ;

One.  OptRepl  ::= ;
Some. OptRepl  ::= "^" ATerm ;

Cont. CSession ::= "." Term1 ;
Done. CSession ::= ;
