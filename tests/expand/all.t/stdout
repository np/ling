
{- Expanded program -}

assert
  'a'
  =
  'a'
  : Char

ap =
  \ (S : Session)-> \ (T : Session)-> proc (c : {[S, ~ T],{~ S, T}})
  split c {f, xo}.
  split xo {x, o}.
  split f [fi, fo].
  ( fwd S (fi, x)
  | fwd T (o, fo))

ap_SInt_SBool =
  proc (c : {[!Int, ?Bool],{?Int, !Bool}})
  split c {f, xo}.
  split xo {x, o}.
  split f [fi, fo].
  ( let x#x : Int <- x.
    fi <- x#x
  | let x#fo : Bool <- fo.
    o <- x#fo )

app_lambda =
  42

app_lambda_2 =
  63

app_lambda_let =
  42

assert
  `true
  =
  `true
  : Bool

assert
  `false
  =
  `false
  : Bool

assert
  \ (x : Bool)-> x
  =
  \ (y : Bool)-> y
  : (b : Bool)-> Bool

assert
  `false
  =
  `false
  : Bool

assert
  proc (r : ?Bool.!Bool)
  let x : Bool <- r.
  r <- x
  =
  proc (r : ?Bool.!Bool)
  let y : Bool <- r.
  r <- y
  : < ?Bool.!Bool >

assert
  proc (r : !Bool)
  r <- `false
  =
  proc (r : !Bool)
  r <- `false
  : < !Bool >

another_not : (x : Bool)-> Bool =
  \ (x : Bool)-> case x of {
    `false -> `true ,
    `true -> `false
  }

pnot =
  proc (c : ?Bool.!Bool)
  let x : Bool <- c.
  c <- (case x of {
    `false -> `true ,
    `true -> `false
  } )

if : (b : Bool)-> (A : Type)-> (t : A)-> (e : A)-> A =
  \ (b : Bool)-> \ (A : Type)-> \ (t : A)-> \ (e : A)-> case b of {
    `false -> e ,
    `true -> t
  }

If : (b : Bool)-> (A : Type)-> (B : Type)-> (t : A)-> (e : B)-> case b of {
    `false -> B ,
    `true -> A
  } =
  \ (b : Bool)-> \ (A : Type)-> \ (B : Type)-> \ (t : A)-> \ (e : B)-> case b of {
    `false -> e ,
    `true -> t
  }

assert
  `false
  =
  `false


assert
  `true
  =
  `true


assert
  `false
  =
  `false


assert
  `false
  =
  `false


assert
  `false
  =
  `false


assert
  `true
  =
  `true


assert
  `false
  =
  `false


assert
  `true
  =
  `true


assert
  `true
  =
  `true


assert
  `true
  =
  `true


assert
  `true
  =
  `true


assert
  `false
  =
  `false


assert
  `false
  =
  `false


assert
  `true
  =
  `true


assert
  `false
  =
  `false


assert
  `true
  =
  `true


assert
  `true
  =
  `true


assert
  `false
  =
  `false


case_con : Int =
  1

case_fun_server =
  proc (c : ?(x : Bool).case x of {
    `false -> {!String, !String},
    `true -> !String
  } )
  let x : Bool <- c.
  @ (case x of {
    `false -> proc (c)
    split c {d, e}.
    d <- "Hello".
    e <- "World" ,
    `true -> proc (c)
    c <- "Hello World!"
  } ) (c)

dbl =
  \ (n : Int)-> n + n

case_proto2 =
  \ (S : Session)-> \ (n : Int)-> \ (p : < S ^ (n + n)>)-> \ (q : < S ^ (n + n)>)-> \ (b : Bool)-> proc (c)
  @ (case b of {
    `false -> q ,
    `true -> p
  } ) (c)

My_Int =
  Int

case_proto : (x : Bool)-> < ?Int > =
  \ (x : Bool)-> proc (c : ?Int)
  @ (case x of {
    `false -> proc (e : ?Int)
    let y : Int <- e ,
    `true -> proc (d : ?Int)
    let y : Int <- d
  } ) (c)

com_new =
  \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> \ (ann : Allocation)-> proc ()
  new/ann [c : S, d : ~ S].
  ( @ p (c)
  | @ q (d))

com_new_SInt =
  \ (ann : Allocation)-> proc ()
  new/ann [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_new_SInt_alloc =
  proc ()
  new/alloc [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_new_SInt_fuse1 =
  proc ()
  new/fuse 1 [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_new_SInt_RBool =
  \ (ann : Allocation)-> proc ()
  new/ann [c : !Int.?Bool, d : ?Int.!Bool].
  ( c <- 42.
    let b#p : Bool <- c
  | let x#q : Int <- d.
    d <- `true )

com_new_SInt_RBool_alloc =
  proc ()
  new/alloc [c : !Int.?Bool, d : ?Int.!Bool].
  ( c <- 42.
    let b#p : Bool <- c
  | let x#q : Int <- d.
    d <- `true )

com_new_SInt_RBool_fuse1 =
  proc ()
  new/fuse 1 [c : !Int.?Bool, d : ?Int.!Bool].
  ( c <- 42.
    let b#p : Bool <- c
  | let x#q : Int <- d.
    d <- `true )

com_new_SInt_RBool_fuse2 =
  proc ()
  new/fuse 2 [c : !Int.?Bool, d : ?Int.!Bool].
  ( c <- 42.
    let b#p : Bool <- c
  | let x#q : Int <- d.
    d <- `true )

com_new_SInt_RBool_fuse3 =
  proc ()
  new/fuse 3 [c : !Int.?Bool, d : ?Int.!Bool].
  ( c <- 42.
    let b#p : Bool <- c
  | let x#q : Int <- d.
    d <- `true )

com_new_mk_ten2 =
  \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> \ (ann : Allocation)-> proc ()
  new/ann [c : S, d : ~ S].
  ( @ p (c)
  | @ q (d))

com_new_mk_ten2_SInt =
  \ (ann : Allocation)-> proc ()
  new/ann [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_new_mk_ten2_SInt_alloc =
  proc ()
  new/alloc [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_new_mk_ten2_SInt_fuse1 =
  proc ()
  new/fuse 1 [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_new_mk_ten2_SInt_fuse2 =
  proc ()
  new/fuse 2 [c : !Int, d : ?Int].
  ( c <- 42
  | let x#q : Int <- d )

com_with_log =
  \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> \ (s : < ~ Log S >)-> proc ()
  new [c : S, c' : ~ S].
  new [d : ~ S, d' : S].
  new [l : ~ Log S, l' : Log S].
  ( @ p (c)
  | @ q (d)
  | @ s (l)
  | fwd S (d', c', l'))

conv_fun =
  \ (A : Type)-> \ (A' : Type)-> \ (B : Type)-> \ (S : Session)-> \ (dom : A' -> A)-> \ (cod : B -> < S >)-> \ (f : A -> B)-> proc (c : {?A', S})
  split c {i, o}.
  let p : A' <- i.
  @ (cod (f (dom p)))(o)

curry =
  \ (S : Session)-> \ (T : Session)-> \ (U : Session)-> proc (c : {[[S, T],~ U],{~ S, {~ T, U}}})
  split c {f, xyo}.
  split xyo {x, yo}.
  split yo {y, o}.
  split f [fxy, fo].
  split fxy [fx, fy].
  ( fwd S (fx, x)
  | fwd T (fy, y)
  | fwd U (o, fo))

curry_SInt_SBool_SDouble =
  proc (c : {[[!Int, !Bool],?Double],{?Int, {?Bool, !Double}}})
  split c {f, xyo}.
  split xyo {x, yo}.
  split yo {y, o}.
  split f [fxy, fo].
  split fxy [fx, fy].
  ( let x#x : Int <- x.
    fx <- x#x
  | let x#y : Bool <- y.
    fy <- x#y
  | let x#fo : Double <- fo.
    o <- x#fo )

cutEmptyParTensor =
  proc ()
  new [c : {}, d : []].
  ( split c {}
  | split d [] )

cut_par_cut =
  proc ()
  ( new [c : !Int, d : ?Int].
    ( c <- 1
    | let x : Int <- d )
  | new [c' : !Int, d' : ?Int].
    ( c' <- 1
    | let x' : Int <- d' ))

cutSendRecv =
  proc ()
  new [c : !Int, d : ?Int].
  ( c <- 1
  | let x : Int <- d )

cut_send_recv_recv_send_with_log =
  proc (logc : !String.!String, logd : !String.!String)
  new [c : !Int.?Int, d : ?Int.!Int].
  ( logd <- "recv d".
    let y : Int <- d.
    logd <- "send d 2".
    d <- 2
  | logc <- "send c 1".
    c <- 1.
    logc <- "recv c".
    let x : Int <- c )

cut_send_recv_recv_send_with_log_prll =
  proc (logc : !String.!String, logd : !String.!String)
  new [c : !Int.?Int, d : ?Int.!Int].
  ( ( logd <- "recv d"
    | let y : Int <- d ).
    ( logd <- "send d 2"
    | d <- 2 )
  | ( logc <- "send c 1"
    | c <- 1 ).
    ( logc <- "recv c"
    | let x : Int <- c ))

dep_fun_server =
  \ (A : Type)-> \ (B : (x : A)-> Type)-> \ (f : (x : A)-> B x)-> proc (c : ?(x : A).!B x)
  let x : A <- c.
  c <- (f x)

div_mod_server_cont =
  proc (c : ?Int.?Int.!Int.!Int)
  let m : Int <- c.
  let n : Int <- c.
  c <- (m / n).
  c <- (m % n)

div_mod_server_explicit_prll =
  proc (rm : ?Int, rn : ?Int, sdiv : !Int, smod : !Int)
  ( let n : Int <- rn
  | let m : Int <- rm ).
  ( sdiv <- (m / n)
  | smod <- (m % n))

div_mod_server_par2_ten2_ten2 =
  proc (r : [?Int, ?Int],s : [!Int, !Int])
  split r [rm, rn].
  split s [sdiv, smod].
  ( let m : Int <- rm
  | let n : Int <- rn ).
  ( sdiv <- (m / n)
  | smod <- (m % n))

div_mod_server_par4 =
  proc (c : {?Int, ?Int, !Int, !Int})
  split c {rm, rn, sdiv, smod}.
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_seq2_ten2_ten2 =
  proc (c : [: [?Int, ?Int],[!Int, !Int]:])
  split c [: r, s :].
  split r [rm, rn].
  split s [sdiv, smod].
  ( let m : Int <- rm
  | let n : Int <- rn ).
  ( sdiv <- (m / n)
  | smod <- (m % n))

div_mod_server_seq4 =
  proc (c : [: ?Int, ?Int, !Int, !Int :])
  split c [: rm, rn, sdiv, smod :].
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_simple =
  proc (rm : ?Int, rn : ?Int, sdiv : !Int, smod : !Int)
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

double =
  proc (a : ?Int, b : !Int)
  let x : Int <- a.
  b <- (x + x)

double_21 =
  proc (b : !Int)
  new (c :* Int).
  c <- 21.
  let x : Int <- c.
  b <- (x + x)

double_21_seq =
  proc (b : !Int)
  new [: c : !Int, c' : ?Int :].
  c <- 21.
  let x : Int <- c'.
  b <- (x + x)

double_21_fused =
  proc (b : !Int)
  b <- 42

double_21_fused_and_reduced =
  proc (b : !Int)
  b <- 42

another_dual =
  \ (S : Session)-> ~ S

dual_dual =
  \ (S : Session)-> \ (p : < S >)-> proc (c : S)
  @ p (c)

assert
  4
  =
  4
  : Int

my_zero =
  0

assert
  (S : Session)-> (T : Session)-> < S ^ 5, T ^ 0 >
  =
  (S : Session)-> (T : Session)-> < S ^ 2, T ^ 0, S, S, S >
  : Type

assert
  (S : Session)-> (m : Int)-> (n : Int)-> < S ^ (m + n)>
  =
  (S : Session)-> (m : Int)-> (n : Int)-> < S ^ m, S ^ n >
  : Type

fake_div_mod_server_ten2 =
  proc (r : [?Int, ?Int],s : [!Int, !Int])
  split r [rm, rn].
  split s [sdiv, smod].
  ( sdiv <- 42
  | smod <- 21 ).
  ( let m : Int <- rm
  | let n : Int <- rn )

feed_fwd_send_then_recv =
  \ (I : Type)-> \ (O : Type)-> \ (i : I)-> \ (f : (x : I)-> O)-> \ (p : < {!I.?O, ?I.!O}>)-> proc ()
  new [a : {!I.?O, ?I.!O},b : [?I.!O, !I.?O]].
  ( @ p (a)
  | split b [c, d].
    ( let x : I <- c.
      c <- (f x)
    | d <- i.
      let o : O <- d ))

feed_fwd_send_then_recv_Int_String_42_showInt =
  proc ()
  new [a : {!Int.?String, ?Int.!String},b : [?Int.!String, !Int.?String]].
  ( split a {c#0#p : !Int.?String, c#1#p : ?Int.!String}.
    let x#c#1#p : Int <- c#1#p.
    c#0#p <- x#c#1#p.
    let x#c#0#p : String <- c#0#p.
    c#1#p <- x#c#0#p
  | split b [c, d].
    ( let x : Int <- c.
      c <- (showInt x)
    | d <- 42.
      let o : String <- d ))

feed_recv =
  \ (p : < ?Int >)-> \ (i : Int)-> proc ()
  new [c : ?Int, d].
  ( @ p (c)
  | d <- i )

feed_send =
  \ (p : < !Int >)-> proc ()
  new [c : !Int, d].
  ( @ p (c)
  | let x : Int <- d )

feed_send_par_recv =
  \ (p : < {!Int, ?Int}>)-> \ (n : Int)-> proc ()
  new [c : {!Int, ?Int},d : [?Int, !Int]].
  ( @ p (c)
  | split d [i, o].
    ( let x : Int <- i
    | o <- n ))

feed_send_ten_recv =
  \ (p : < [!Int, ?Int]>)-> \ (f : (x : Int)-> Int)-> proc ()
  new [c : [!Int, ?Int],d : {?Int, !Int}].
  ( @ p (c)
  | split d {i, o}.
    let x : Int <- i.
    o <- (f x))

feed_send_then_recv =
  \ (p : < !Int.?Int >)-> \ (f : (x : Int)-> Int)-> proc ()
  new [c : !Int.?Int, d].
  ( @ p (c)
  | let x : Int <- d.
    d <- (f x))

flexible_telescope : (A : Type)-> (B : Type)-> (x : A)-> (y : A)-> (z : B)-> (t : B)-> Int =
  \ (A : Type)-> \ (B : Type)-> \ (x : A)-> \ (y : A)-> \ (z : B)-> \ (t : B)-> 42

Fwd_diff =
  \ (m : Int)-> \ (n : Int)-> {[: ?Int ^ (m + n):], [: !Int ^ n :]}

fwd_diff1 =
  \ (n : Int)-> proc (c : {[: ?Int ^ (1 + n):], [: !Int ^ n :]})
  split c {a, b}.
  split a [: a0, ai ^ n :].
  split b [: bi ^ n :].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ n :].
  sequence ^ n
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)

fwd_diff1_10 : < {[: ?Int ^ 11 :], [: !Int ^ 10 :]}> =
  proc (c : {[: ?Int ^ 11 :], [: !Int ^ 10 :]})
  split c {a, b}.
  split a [: a0, ai ^ 10 :].
  split b [: bi ^ 10 :].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ 10 :].
  sequence ^ 10
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)

fwd_diff0 : (n : Int)-> < {[: ?Int ^ (0 + n):], [: !Int ^ n :]}> =
  \ (n : Int)-> proc (c : {[: ?Int ^ (0 + n):], [: !Int ^ n :]})
  split c {c#0 : [: ?Int ^ n :], c#1 : [: !Int ^ n :]}.
  split c#0 [: c#0#0 ^ n : ?Int ^ n :].
  split c#1 [: c#1#0 ^ n : !Int ^ n :].
  sequence ^ n
    (let x#c#0#0 : Int <- c#0#0.
    c#1#0 <- x#c#0#0)

fwd_diff_succ =
  \ (ann : Allocation)-> \ (n : Int)-> \ (m1 : Int)-> \ (p : < {[: ?Int ^ (m1 + n):], [: !Int ^ n :]}>)-> proc (ad : {[: ?Int ^ ((1 + m1)+ n):], [: !Int ^ n :]})
  split ad {a : [: ?Int ^ (1 + m1 + n):], d : [: !Int ^ n :]}.
  new/ann [: b : [: !Int ^ (m1 + n):], c :].
  split a [: a0, ai ^ (m1 + n):].
  split b [: bi ^ (m1 + n):].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ (m1 + n):].
  (sequence ^ (m1 + n)
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)).
  @ p {c, d}

fwd_diff2 : (ann : Allocation)-> (n : Int)-> < {[: ?Int ^ (2 + n):], [: !Int ^ n :]}> =
  \ (ann : Allocation)-> \ (n : Int)-> proc (ad : {[: ?Int ^ (2 + n):], [: !Int ^ n :]})
  split ad {a : [: ?Int ^ (1 + 1 + n):], d : [: !Int ^ n :]}.
  new/ann [: b : [: !Int ^ (1 + n):], c :].
  split a [: a0, ai ^ (1 + n):].
  split b [: bi ^ (1 + n):].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ (1 + n):].
  (sequence ^ (1 + n)
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)).
  split c [: a0#p, ai#p ^ n :].
  split d [: bi#p ^ n :].
  new/alloc (acc#p :* Int).
  let x#a0#p : Int <- a0#p.
  acc#p <- x#a0#p.
  split acc#p [: acci#p ^ n :].
  sequence ^ n
    (let x#p : Int <- ai#p.
    let y#p : Int <- acci#p.
    bi#p <- (x#p - y#p).
    acci#p <- x#p)

fwd_diff2_10_alloc : < {[: ?Int ^ 12 :], [: !Int ^ 10 :]}> =
  proc (ad : {[: ?Int ^ 12 :], [: !Int ^ 10 :]})
  split ad {a : [: ?Int ^ 12 :], d : [: !Int ^ 10 :]}.
  new/alloc [: b : [: !Int ^ 11 :], c :].
  split a [: a0, ai ^ 11 :].
  split b [: bi ^ 11 :].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ 11 :].
  (sequence ^ 11
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)).
  split c [: a0#p, ai#p ^ 10 :].
  split d [: bi#p ^ 10 :].
  new/alloc (acc#p :* Int).
  let x#a0#p : Int <- a0#p.
  acc#p <- x#a0#p.
  split acc#p [: acci#p ^ 10 :].
  sequence ^ 10
    (let x#p : Int <- ai#p.
    let y#p : Int <- acci#p.
    bi#p <- (x#p - y#p).
    acci#p <- x#p)

fwd_diff3 : (ann : Allocation)-> (n : Int)-> < {[: ?Int ^ (3 + n):], [: !Int ^ n :]}> =
  \ (ann : Allocation)-> \ (n : Int)-> proc (ad : {[: ?Int ^ (3 + n):], [: !Int ^ n :]})
  split ad {a : [: ?Int ^ (1 + 2 + n):], d : [: !Int ^ n :]}.
  new/ann [: b : [: !Int ^ (2 + n):], c :].
  split a [: a0, ai ^ (2 + n):].
  split b [: bi ^ (2 + n):].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ (2 + n):].
  (sequence ^ (2 + n)
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)).
  new/ann [: b#p : [: !Int ^ (1 + n):], c#p :].
  split c [: a0#p, ai#p ^ (1 + n):].
  split b#p [: bi#p ^ (1 + n):].
  new/alloc (acc#p :* Int).
  let x#a0#p : Int <- a0#p.
  acc#p <- x#a0#p.
  split acc#p [: acci#p ^ (1 + n):].
  (sequence ^ (1 + n)
    (let x#p : Int <- ai#p.
    let y#p : Int <- acci#p.
    bi#p <- (x#p - y#p).
    acci#p <- x#p)).
  split c#p [: a0#p#p, ai#p#p ^ n :].
  split d [: bi#p#p ^ n :].
  new/alloc (acc#p#p :* Int).
  let x#a0#p#p : Int <- a0#p#p.
  acc#p#p <- x#a0#p#p.
  split acc#p#p [: acci#p#p ^ n :].
  sequence ^ n
    (let x#p#p : Int <- ai#p#p.
    let y#p#p : Int <- acci#p#p.
    bi#p#p <- (x#p#p - y#p#p).
    acci#p#p <- x#p#p)

recInt : (A : (n : Int)-> Type)-> (e : String)-> (z : A 0)-> (s : (n1 : Int)-> (a : A n1)-> A (1 + n1)) -> (n : Int)-> A n

fwd_diff : (ann : Allocation)-> (m : Int)-> (n : Int)-> < {[: ?Int ^ (m + n):], [: !Int ^ n :]}> =
  \ (ann : Allocation)-> \ (m0 : Int)-> \ (n : Int)-> recInt (\ (m : Int)-> < {[: ?Int ^ (m + n):], [: !Int ^ n :]}>)"m < 0" (proc (c : {[: ?Int ^ (0 + n):], [: !Int ^ n :]})
  split c {c#0 : [: ?Int ^ n :], c#1 : [: !Int ^ n :]}.
  split c#0 [: c#0#0 ^ n : ?Int ^ n :].
  split c#1 [: c#1#0 ^ n : !Int ^ n :].
  sequence ^ n
    (let x#c#0#0 : Int <- c#0#0.
    c#1#0 <- x#c#0#0)) (\ (m1 : Int)-> \ (p : < {[: ?Int ^ (m1 + n):], [: !Int ^ n :]}>)-> proc (ad : {[: ?Int ^ ((1 + m1)+ n):], [: !Int ^ n :]})
  split ad {a : [: ?Int ^ (1 + m1 + n):], d : [: !Int ^ n :]}.
  new/ann [: b : [: !Int ^ (m1 + n):], c :].
  split a [: a0, ai ^ (m1 + n):].
  split b [: bi ^ (m1 + n):].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ (m1 + n):].
  (sequence ^ (m1 + n)
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)).
  @ p {c, d}) m0

tabulate_seq =
  \ (A : Type)-> \ (f : (i : Int)-> A)-> \ (n : Int)-> proc (a : [: !A ^ n :])
  split a [: a_i ^ n :].
  sequence ^ n with i
    a_i <- (f i)

main =
  proc (cc : [: !Int ^ 7 :])
  new/alloc [: a : [: !Int ^ 10 :], bb :].
  split a [: a_i ^ 10 :].
  (sequence ^ 10 with i
    a_i <- (10 - i)).
  new/alloc [: b : [: !Int ^ 9 :], c :].
  split bb [: a0, ai ^ 9 :].
  split b [: bi ^ 9 :].
  new/alloc (acc :* Int).
  let x#a0 : Int <- a0.
  acc <- x#a0.
  split acc [: acci ^ 9 :].
  (sequence ^ 9
    (let x : Int <- ai.
    let y : Int <- acci.
    bi <- (x - y).
    acci <- x)).
  new/alloc [: b#p : [: !Int ^ 8 :], c#p :].
  split c [: a0#p, ai#p ^ 8 :].
  split b#p [: bi#p ^ 8 :].
  new/alloc (acc#p :* Int).
  let x#a0#p : Int <- a0#p.
  acc#p <- x#a0#p.
  split acc#p [: acci#p ^ 8 :].
  (sequence ^ 8
    (let x#p : Int <- ai#p.
    let y#p : Int <- acci#p.
    bi#p <- (x#p - y#p).
    acci#p <- x#p)).
  split c#p [: a0#p#p, ai#p#p ^ 7 :].
  split cc [: bi#p#p ^ 7 :].
  new/alloc (acc#p#p :* Int).
  let x#a0#p#p : Int <- a0#p#p.
  acc#p#p <- x#a0#p#p.
  split acc#p#p [: acci#p#p ^ 7 :].
  sequence ^ 7
    (let x#p#p : Int <- ai#p#p.
    let y#p#p : Int <- acci#p#p.
    bi#p#p <- (x#p#p - y#p#p).
    acci#p#p <- x#p#p)

fun1_to_proc_ord =
  \ (I : Type)-> \ (O : Type)-> \ (f : (x : I)-> O)-> proc (c : [: ?I, !O :])
  split c [: i, o :].
  let x : I <- i.
  o <- (f x)

fun1_to_proc_par2 =
  \ (I : Type)-> \ (O : Type)-> \ (f : (x : I)-> O)-> proc (i : ?I, o : !O)
  let x : I <- i.
  o <- (f x)

fun1_to_proc_seq =
  \ (I : Type)-> \ (O : Type)-> \ (f : (x : I)-> O)-> proc (c : ?I.!O)
  let x : I <- c.
  c <- (f x)

fwd0_snd0 =
  proc (c : {})
  split c {}

fwd1_par2_rcv =
  proc (c : {{?Int, ?Bool}})
  split c {c#0 : {?Int, ?Bool}}.
  split c#0 {c#0#0 : ?Int, c#0#1 : ?Bool}.
  ( let x#c#0#0 : Int <- c#0#0
  | let x#c#0#1 : Bool <- c#0#1 )

fwd1_rcv =
  proc (c : {?Int})
  split c {c#0 : ?Int}.
  let x#c#0 : Int <- c#0

fwd1_seq2_rcv =
  proc (c : {[: ?Int, ?Bool :]})
  split c {c#0 : [: ?Int, ?Bool :]}.
  split c#0 [: c#0#0 : ?Int, c#0#1 : ?Bool :].
  let x#c#0#0 : Int <- c#0#0.
  let x#c#0#1 : Bool <- c#0#1

fwd1_ten2_rcv =
  proc (c : {[?Int, ?Bool]})
  split c {c#0 : [?Int, ?Bool]}.
  split c#0 [c#0#0 : ?Int, c#0#1 : ?Bool].
  ( let x#c#0#0 : Int <- c#0#0
  | let x#c#0#1 : Bool <- c#0#1 )

fwd2_par2_ten2 =
  proc (c : {{?Int, !Int.?Int},[!Int, ?Int.!Int]})
  split c {c#0 : {?Int, !Int.?Int},c#1 : [!Int, ?Int.!Int]}.
  split c#0 {c#0#0 : ?Int, c#0#1 : !Int.?Int}.
  split c#1 [c#1#0 : !Int, c#1#1 : ?Int.!Int].
  ( let x#c#0#0 : Int <- c#0#0.
    c#1#0 <- x#c#0#0
  | let x#c#1#1 : Int <- c#1#1.
    c#0#1 <- x#c#1#1.
    let x#c#0#1 : Int <- c#0#1.
    c#1#1 <- x#c#0#1 )

fwd3_par2_ten2_ten2 =
  proc (c : {{?Int, !Int.?Int},[!Int, ?Int.!Int],{!Int, !Int.!Int}})
  split c {c#0 : {?Int, !Int.?Int},c#1 : [!Int, ?Int.!Int],c#2 : {!Int, !Int.!Int}}.
  split c#0 {c#0#0 : ?Int, c#0#1 : !Int.?Int}.
  split c#1 [c#1#0 : !Int, c#1#1 : ?Int.!Int].
  split c#2 {c#2#0 : !Int, c#2#1 : !Int.!Int}.
  ( let x#c#0#0 : Int <- c#0#0.
    ( c#1#0 <- x#c#0#0
    | c#2#0 <- x#c#0#0 )
  | let x#c#1#1 : Int <- c#1#1.
    ( c#0#1 <- x#c#1#1
    | c#2#1 <- x#c#1#1 ).
    let x#c#0#1 : Int <- c#0#1.
    ( c#1#1 <- x#c#0#1
    | c#2#1 <- x#c#0#1 ))

fwd3_seq2_seq2_seq2 =
  proc (c : {[: ?Int, !Int.?Int :], [: !Int, ?Int.!Int :], [: !Int, !Int.!Int :]})
  split c {c#0 : [: ?Int, !Int.?Int :], c#1 : [: !Int, ?Int.!Int :], c#2 : [: !Int, !Int.!Int :]}.
  split c#0 [: c#0#0 : ?Int, c#0#1 : !Int.?Int :].
  split c#1 [: c#1#0 : !Int, c#1#1 : ?Int.!Int :].
  split c#2 [: c#2#0 : !Int, c#2#1 : !Int.!Int :].
  let x#c#0#0 : Int <- c#0#0.
  ( c#1#0 <- x#c#0#0
  | c#2#0 <- x#c#0#0 ).
  let x#c#1#1 : Int <- c#1#1.
  ( c#0#1 <- x#c#1#1
  | c#2#1 <- x#c#1#1 ).
  let x#c#0#1 : Int <- c#0#1.
  ( c#1#1 <- x#c#0#1
  | c#2#1 <- x#c#0#1 )

fwd_par0_ten0 =
  proc (i : {}, o : [])
  split i {}.
  split o []

fwd_par2_ten2_expanded =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int])
  split o [o0, o1].
  split i {i0, i1}.
  ( let xi0 : Int <- i0.
    o0 <- xi0
  | let xo1 : Int <- o1.
    i1 <- xo1.
    let xi1 : Int <- i1.
    o1 <- xi1 )

fwd_par2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int])
  split i {i#0 : ?Int, i#1 : !Int.?Int}.
  split o [o#0 : !Int, o#1 : ?Int.!Int].
  ( let x#i#0 : Int <- i#0.
    o#0 <- x#i#0
  | let x#o#1 : Int <- o#1.
    i#1 <- x#o#1.
    let x#i#1 : Int <- i#1.
    o#1 <- x#i#1 )

fwd_par2_ten2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int],l : {!Int, !Int.!Int})
  split i {i#0 : ?Int, i#1 : !Int.?Int}.
  split o [o#0 : !Int, o#1 : ?Int.!Int].
  split l {l#0 : !Int, l#1 : !Int.!Int}.
  ( let x#i#0 : Int <- i#0.
    ( o#0 <- x#i#0
    | l#0 <- x#i#0 )
  | let x#o#1 : Int <- o#1.
    ( i#1 <- x#o#1
    | l#1 <- x#o#1 ).
    let x#i#1 : Int <- i#1.
    ( o#1 <- x#i#1
    | l#1 <- x#i#1 ))

fwd_par2_ten2_ten2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int],l : {!Int, !Int.!Int},m : {!Int, !Int.!Int})
  split i {i#0 : ?Int, i#1 : !Int.?Int}.
  split o [o#0 : !Int, o#1 : ?Int.!Int].
  split l {l#0 : !Int, l#1 : !Int.!Int}.
  split m {m#0 : !Int, m#1 : !Int.!Int}.
  ( let x#i#0 : Int <- i#0.
    ( o#0 <- x#i#0
    | l#0 <- x#i#0
    | m#0 <- x#i#0 )
  | let x#o#1 : Int <- o#1.
    ( i#1 <- x#o#1
    | l#1 <- x#o#1
    | m#1 <- x#o#1 ).
    let x#i#1 : Int <- i#1.
    ( o#1 <- x#i#1
    | l#1 <- x#i#1
    | m#1 <- x#i#1 ))

fwd_parN_tenN =
  \ (n : Int)-> proc (i : {?Int ^ n},o : [!Int ^ n])
  split i {i#0 ^ n : ?Int ^ n}.
  split o [o#0 ^ n : !Int ^ n].
  parallel ^ n
    (let x#i#0 : Int <- i#0.
    o#0 <- x#i#0)

fwd_par10_ten10 =
  proc (i : {?Int ^ 10},o : [!Int ^ 10])
  split i {i#0 ^ 10 : ?Int ^ 10}.
  split o [o#0 ^ 10 : !Int ^ 10].
  parallel ^ 10
    (let x#i#0 : Int <- i#0.
    o#0 <- x#i#0)

fwd_send_recv =
  proc (i : ?Int, o : !Int)
  let x#i : Int <- i.
  o <- x#i

fwd_send_recv_recv_auto =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int)
  let x#d : Int <- d.
  c <- x#d.
  let x#c : Int <- c.
  d <- x#c.
  let y#c : Int <- c.
  d <- y#c

fwd_send_recv_recv_manually =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int)
  let x : Int <- d.
  c <- x.
  let y : Int <- c.
  d <- y.
  let z : Int <- c.
  d <- z

fwd_send_recv_recv_send =
  proc (i : ?Int.!Int, o : !Int.?Int)
  let x#i : Int <- i.
  o <- x#i.
  let x#o : Int <- o.
  i <- x#o

fwd_send_recv_recv_with_listener_auto =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int, e : !Int.!Int.!Int)
  let x#d : Int <- d.
  ( c <- x#d
  | e <- x#d ).
  let x#c : Int <- c.
  ( d <- x#c
  | e <- x#c ).
  let y#c : Int <- c.
  ( d <- y#c
  | e <- y#c )

fwd_send_recv_recv_with_listener_manually =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int, e : !Int.!Int.!Int)
  let x : Int <- d.
  ( c <- x
  | e <- x ).
  let y : Int <- c.
  ( d <- y
  | e <- y ).
  let z : Int <- c.
  ( d <- z
  | e <- z )

fwd_seq2_seq2_seq2 =
  proc (i : [: ?Int, !Int.?Int :], o : [: !Int, ?Int.!Int :], l : [: !Int, !Int.!Int :])
  split i [: i#0 : ?Int, i#1 : !Int.?Int :].
  split o [: o#0 : !Int, o#1 : ?Int.!Int :].
  split l [: l#0 : !Int, l#1 : !Int.!Int :].
  let x#i#0 : Int <- i#0.
  ( o#0 <- x#i#0
  | l#0 <- x#i#0 ).
  let x#o#1 : Int <- o#1.
  ( i#1 <- x#o#1
  | l#1 <- x#o#1 ).
  let x#i#1 : Int <- i#1.
  ( o#1 <- x#i#1
  | l#1 <- x#i#1 )

fwd_ten2_par2 =
  proc (i : [?Int, !Int.?Int],o : {!Int, ?Int.!Int})
  split i [i#0 : ?Int, i#1 : !Int.?Int].
  split o {o#0 : !Int, o#1 : ?Int.!Int}.
  ( let x#i#0 : Int <- i#0.
    o#0 <- x#i#0
  | let x#o#1 : Int <- o#1.
    i#1 <- x#o#1.
    let x#i#1 : Int <- i#1.
    o#1 <- x#i#1 )

split_nested_seq_core =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (D : Session)-> proc (i : [: ~ A, ~ B, ~ C, ~ D :], o : [: [: A, B :], [: C, D :] :])
  split i [: na, nb, nc, nd :].
  split o [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  fwd A (a, na).
  fwd B (b, nb).
  fwd C (c, nc).
  fwd D (d, nd)

group_nested_seq : (A : Session)-> (B : Session)-> (C : Session)-> (D : Session)-> < {[: [: ~ A, ~ B :], [: ~ C, ~ D :] :], [: A, B, C, D :]}> =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (D : Session)-> proc (c : {[: [: ~ A, ~ B :], [: ~ C, ~ D :] :], [: A, B, C, D :]})
  split c {i, o}.
  split o [: na, nb, nc, nd :].
  split i [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  fwd (~ A)(a, na).
  fwd (~ B)(b, nb).
  fwd (~ C)(c, nc).
  fwd (~ D)(d, nd)

group_nested_seq_SInt_SDouble_SBool_SString =
  proc (c : {[: [: ?Int, ?Double :], [: ?Bool, ?String :] :], [: !Int, !Double, !Bool, !String :]})
  split c {i, o}.
  split o [: na, nb, nc, nd :].
  split i [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  let x#a : Int <- a.
  na <- x#a.
  let x#b : Double <- b.
  nb <- x#b.
  let x#c : Bool <- c.
  nc <- x#c.
  let x#d : String <- d.
  nd <- x#d

idProc =
  proc (c : ?Int, d : !Int)
  let y : Int <- c.
  d <- y

idType =
  \ (idTypeA : Type)-> idTypeA

idTypeA : Type

idTypeX : idTypeA

assert
  42
  =
  42


i42 : Int =
  42

one : Int =
  1

suc : (x : Int)-> Int =
  _+_ 1

doubleInt : (x : Int)-> Int =
  \ (x : Int)-> x + x

data ABC = `a | `b | `c

rot : (x : ABC)-> ABC =
  \ (x : ABC)-> case x of {
    `a -> `b ,
    `b -> `c ,
    `c -> `a
  }

rot2 : (x : ABC)-> ABC =
  \ (x : ABC)-> case case x of {
    `a -> `b ,
    `b -> `c ,
    `c -> `a
  } of {
    `a -> `b ,
    `b -> `c ,
    `c -> `a
  }

let42ann =
  84

let42 =
  84

let_example =
  proc (c : ?Int.!Int)
  let x : Int <- c.
  c <- (x + x)

let_in_proc_for_session =
  proc (c : ?Int)
  let x : Int <- c

let_let =
  1

let_order =
  3

let_order_proc =
  proc (c : !Int)
  c <- 3

letrecv_ann =
  proc (c : ?Int.!Int)
  let x : Int <- c.
  c <- (x + x)

letrecv =
  proc (c : ?Int.!Int)
  let x : Int <- c.
  c <- (x + x)

letsession =
  proc (c)
  split c {c#0 : {{{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}},{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}}, {{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}},{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}}},c#1 : [[[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]],[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]]], [[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]],[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]]]]}.
  split c#0 {c#0#0 : {{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}},{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}}, c#0#1 : {{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}},{{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}}}.
  split c#1 [c#1#0 : [[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]],[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]]], c#1#1 : [[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]],[[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]]]].
  ( split c#0#0 {c#0#0#0 : {{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}},c#0#0#1 : {{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}}.
    split c#1#0 [c#1#0#0 : [[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]],c#1#0#1 : [[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]]].
    ( split c#0#0#0 {c#0#0#0#0 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, c#0#0#0#1 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}.
      split c#1#0#0 [c#1#0#0#0 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], c#1#0#0#1 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]].
      ( split c#0#0#0#0 {c#0#0#0#0#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#0#0#0#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#0#0#0 [c#1#0#0#0#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#0#0#0#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#0#0#0#0 {c#0#0#0#0#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#0#0#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#0#0#0 [c#1#0#0#0#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#0#0#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#0#0#0#0 {c#0#0#0#0#0#0#0 : {?Int, ?Int},c#0#0#0#0#0#0#1 : {?Int, ?Int}}.
            split c#1#0#0#0#0#0 [c#1#0#0#0#0#0#0 : [!Int, !Int],c#1#0#0#0#0#0#1 : [!Int, !Int]].
            ( split c#0#0#0#0#0#0#0 {c#0#0#0#0#0#0#0#0 : ?Int, c#0#0#0#0#0#0#0#1 : ?Int}.
              split c#1#0#0#0#0#0#0 [c#1#0#0#0#0#0#0#0 : !Int, c#1#0#0#0#0#0#0#1 : !Int].
              ( let x#c#0#0#0#0#0#0#0#0 : Int <- c#0#0#0#0#0#0#0#0.
                c#1#0#0#0#0#0#0#0 <- x#c#0#0#0#0#0#0#0#0
              | let x#c#0#0#0#0#0#0#0#1 : Int <- c#0#0#0#0#0#0#0#1.
                c#1#0#0#0#0#0#0#1 <- x#c#0#0#0#0#0#0#0#1 )
            | split c#0#0#0#0#0#0#1 {c#0#0#0#0#0#0#1#0 : ?Int, c#0#0#0#0#0#0#1#1 : ?Int}.
              split c#1#0#0#0#0#0#1 [c#1#0#0#0#0#0#1#0 : !Int, c#1#0#0#0#0#0#1#1 : !Int].
              ( let x#c#0#0#0#0#0#0#1#0 : Int <- c#0#0#0#0#0#0#1#0.
                c#1#0#0#0#0#0#1#0 <- x#c#0#0#0#0#0#0#1#0
              | let x#c#0#0#0#0#0#0#1#1 : Int <- c#0#0#0#0#0#0#1#1.
                c#1#0#0#0#0#0#1#1 <- x#c#0#0#0#0#0#0#1#1 ))
          | split c#0#0#0#0#0#1 {c#0#0#0#0#0#1#0 : {?Int, ?Int},c#0#0#0#0#0#1#1 : {?Int, ?Int}}.
            split c#1#0#0#0#0#1 [c#1#0#0#0#0#1#0 : [!Int, !Int],c#1#0#0#0#0#1#1 : [!Int, !Int]].
            ( split c#0#0#0#0#0#1#0 {c#0#0#0#0#0#1#0#0 : ?Int, c#0#0#0#0#0#1#0#1 : ?Int}.
              split c#1#0#0#0#0#1#0 [c#1#0#0#0#0#1#0#0 : !Int, c#1#0#0#0#0#1#0#1 : !Int].
              ( let x#c#0#0#0#0#0#1#0#0 : Int <- c#0#0#0#0#0#1#0#0.
                c#1#0#0#0#0#1#0#0 <- x#c#0#0#0#0#0#1#0#0
              | let x#c#0#0#0#0#0#1#0#1 : Int <- c#0#0#0#0#0#1#0#1.
                c#1#0#0#0#0#1#0#1 <- x#c#0#0#0#0#0#1#0#1 )
            | split c#0#0#0#0#0#1#1 {c#0#0#0#0#0#1#1#0 : ?Int, c#0#0#0#0#0#1#1#1 : ?Int}.
              split c#1#0#0#0#0#1#1 [c#1#0#0#0#0#1#1#0 : !Int, c#1#0#0#0#0#1#1#1 : !Int].
              ( let x#c#0#0#0#0#0#1#1#0 : Int <- c#0#0#0#0#0#1#1#0.
                c#1#0#0#0#0#1#1#0 <- x#c#0#0#0#0#0#1#1#0
              | let x#c#0#0#0#0#0#1#1#1 : Int <- c#0#0#0#0#0#1#1#1.
                c#1#0#0#0#0#1#1#1 <- x#c#0#0#0#0#0#1#1#1 )))
        | split c#0#0#0#0#1 {c#0#0#0#0#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#0#0#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#0#0#1 [c#1#0#0#0#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#0#0#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#0#0#1#0 {c#0#0#0#0#1#0#0 : {?Int, ?Int},c#0#0#0#0#1#0#1 : {?Int, ?Int}}.
            split c#1#0#0#0#1#0 [c#1#0#0#0#1#0#0 : [!Int, !Int],c#1#0#0#0#1#0#1 : [!Int, !Int]].
            ( split c#0#0#0#0#1#0#0 {c#0#0#0#0#1#0#0#0 : ?Int, c#0#0#0#0#1#0#0#1 : ?Int}.
              split c#1#0#0#0#1#0#0 [c#1#0#0#0#1#0#0#0 : !Int, c#1#0#0#0#1#0#0#1 : !Int].
              ( let x#c#0#0#0#0#1#0#0#0 : Int <- c#0#0#0#0#1#0#0#0.
                c#1#0#0#0#1#0#0#0 <- x#c#0#0#0#0#1#0#0#0
              | let x#c#0#0#0#0#1#0#0#1 : Int <- c#0#0#0#0#1#0#0#1.
                c#1#0#0#0#1#0#0#1 <- x#c#0#0#0#0#1#0#0#1 )
            | split c#0#0#0#0#1#0#1 {c#0#0#0#0#1#0#1#0 : ?Int, c#0#0#0#0#1#0#1#1 : ?Int}.
              split c#1#0#0#0#1#0#1 [c#1#0#0#0#1#0#1#0 : !Int, c#1#0#0#0#1#0#1#1 : !Int].
              ( let x#c#0#0#0#0#1#0#1#0 : Int <- c#0#0#0#0#1#0#1#0.
                c#1#0#0#0#1#0#1#0 <- x#c#0#0#0#0#1#0#1#0
              | let x#c#0#0#0#0#1#0#1#1 : Int <- c#0#0#0#0#1#0#1#1.
                c#1#0#0#0#1#0#1#1 <- x#c#0#0#0#0#1#0#1#1 ))
          | split c#0#0#0#0#1#1 {c#0#0#0#0#1#1#0 : {?Int, ?Int},c#0#0#0#0#1#1#1 : {?Int, ?Int}}.
            split c#1#0#0#0#1#1 [c#1#0#0#0#1#1#0 : [!Int, !Int],c#1#0#0#0#1#1#1 : [!Int, !Int]].
            ( split c#0#0#0#0#1#1#0 {c#0#0#0#0#1#1#0#0 : ?Int, c#0#0#0#0#1#1#0#1 : ?Int}.
              split c#1#0#0#0#1#1#0 [c#1#0#0#0#1#1#0#0 : !Int, c#1#0#0#0#1#1#0#1 : !Int].
              ( let x#c#0#0#0#0#1#1#0#0 : Int <- c#0#0#0#0#1#1#0#0.
                c#1#0#0#0#1#1#0#0 <- x#c#0#0#0#0#1#1#0#0
              | let x#c#0#0#0#0#1#1#0#1 : Int <- c#0#0#0#0#1#1#0#1.
                c#1#0#0#0#1#1#0#1 <- x#c#0#0#0#0#1#1#0#1 )
            | split c#0#0#0#0#1#1#1 {c#0#0#0#0#1#1#1#0 : ?Int, c#0#0#0#0#1#1#1#1 : ?Int}.
              split c#1#0#0#0#1#1#1 [c#1#0#0#0#1#1#1#0 : !Int, c#1#0#0#0#1#1#1#1 : !Int].
              ( let x#c#0#0#0#0#1#1#1#0 : Int <- c#0#0#0#0#1#1#1#0.
                c#1#0#0#0#1#1#1#0 <- x#c#0#0#0#0#1#1#1#0
              | let x#c#0#0#0#0#1#1#1#1 : Int <- c#0#0#0#0#1#1#1#1.
                c#1#0#0#0#1#1#1#1 <- x#c#0#0#0#0#1#1#1#1 ))))
      | split c#0#0#0#1 {c#0#0#0#1#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#0#0#1#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#0#0#1 [c#1#0#0#1#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#0#0#1#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#0#0#1#0 {c#0#0#0#1#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#0#1#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#0#1#0 [c#1#0#0#1#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#0#1#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#0#1#0#0 {c#0#0#0#1#0#0#0 : {?Int, ?Int},c#0#0#0#1#0#0#1 : {?Int, ?Int}}.
            split c#1#0#0#1#0#0 [c#1#0#0#1#0#0#0 : [!Int, !Int],c#1#0#0#1#0#0#1 : [!Int, !Int]].
            ( split c#0#0#0#1#0#0#0 {c#0#0#0#1#0#0#0#0 : ?Int, c#0#0#0#1#0#0#0#1 : ?Int}.
              split c#1#0#0#1#0#0#0 [c#1#0#0#1#0#0#0#0 : !Int, c#1#0#0#1#0#0#0#1 : !Int].
              ( let x#c#0#0#0#1#0#0#0#0 : Int <- c#0#0#0#1#0#0#0#0.
                c#1#0#0#1#0#0#0#0 <- x#c#0#0#0#1#0#0#0#0
              | let x#c#0#0#0#1#0#0#0#1 : Int <- c#0#0#0#1#0#0#0#1.
                c#1#0#0#1#0#0#0#1 <- x#c#0#0#0#1#0#0#0#1 )
            | split c#0#0#0#1#0#0#1 {c#0#0#0#1#0#0#1#0 : ?Int, c#0#0#0#1#0#0#1#1 : ?Int}.
              split c#1#0#0#1#0#0#1 [c#1#0#0#1#0#0#1#0 : !Int, c#1#0#0#1#0#0#1#1 : !Int].
              ( let x#c#0#0#0#1#0#0#1#0 : Int <- c#0#0#0#1#0#0#1#0.
                c#1#0#0#1#0#0#1#0 <- x#c#0#0#0#1#0#0#1#0
              | let x#c#0#0#0#1#0#0#1#1 : Int <- c#0#0#0#1#0#0#1#1.
                c#1#0#0#1#0#0#1#1 <- x#c#0#0#0#1#0#0#1#1 ))
          | split c#0#0#0#1#0#1 {c#0#0#0#1#0#1#0 : {?Int, ?Int},c#0#0#0#1#0#1#1 : {?Int, ?Int}}.
            split c#1#0#0#1#0#1 [c#1#0#0#1#0#1#0 : [!Int, !Int],c#1#0#0#1#0#1#1 : [!Int, !Int]].
            ( split c#0#0#0#1#0#1#0 {c#0#0#0#1#0#1#0#0 : ?Int, c#0#0#0#1#0#1#0#1 : ?Int}.
              split c#1#0#0#1#0#1#0 [c#1#0#0#1#0#1#0#0 : !Int, c#1#0#0#1#0#1#0#1 : !Int].
              ( let x#c#0#0#0#1#0#1#0#0 : Int <- c#0#0#0#1#0#1#0#0.
                c#1#0#0#1#0#1#0#0 <- x#c#0#0#0#1#0#1#0#0
              | let x#c#0#0#0#1#0#1#0#1 : Int <- c#0#0#0#1#0#1#0#1.
                c#1#0#0#1#0#1#0#1 <- x#c#0#0#0#1#0#1#0#1 )
            | split c#0#0#0#1#0#1#1 {c#0#0#0#1#0#1#1#0 : ?Int, c#0#0#0#1#0#1#1#1 : ?Int}.
              split c#1#0#0#1#0#1#1 [c#1#0#0#1#0#1#1#0 : !Int, c#1#0#0#1#0#1#1#1 : !Int].
              ( let x#c#0#0#0#1#0#1#1#0 : Int <- c#0#0#0#1#0#1#1#0.
                c#1#0#0#1#0#1#1#0 <- x#c#0#0#0#1#0#1#1#0
              | let x#c#0#0#0#1#0#1#1#1 : Int <- c#0#0#0#1#0#1#1#1.
                c#1#0#0#1#0#1#1#1 <- x#c#0#0#0#1#0#1#1#1 )))
        | split c#0#0#0#1#1 {c#0#0#0#1#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#0#1#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#0#1#1 [c#1#0#0#1#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#0#1#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#0#1#1#0 {c#0#0#0#1#1#0#0 : {?Int, ?Int},c#0#0#0#1#1#0#1 : {?Int, ?Int}}.
            split c#1#0#0#1#1#0 [c#1#0#0#1#1#0#0 : [!Int, !Int],c#1#0#0#1#1#0#1 : [!Int, !Int]].
            ( split c#0#0#0#1#1#0#0 {c#0#0#0#1#1#0#0#0 : ?Int, c#0#0#0#1#1#0#0#1 : ?Int}.
              split c#1#0#0#1#1#0#0 [c#1#0#0#1#1#0#0#0 : !Int, c#1#0#0#1#1#0#0#1 : !Int].
              ( let x#c#0#0#0#1#1#0#0#0 : Int <- c#0#0#0#1#1#0#0#0.
                c#1#0#0#1#1#0#0#0 <- x#c#0#0#0#1#1#0#0#0
              | let x#c#0#0#0#1#1#0#0#1 : Int <- c#0#0#0#1#1#0#0#1.
                c#1#0#0#1#1#0#0#1 <- x#c#0#0#0#1#1#0#0#1 )
            | split c#0#0#0#1#1#0#1 {c#0#0#0#1#1#0#1#0 : ?Int, c#0#0#0#1#1#0#1#1 : ?Int}.
              split c#1#0#0#1#1#0#1 [c#1#0#0#1#1#0#1#0 : !Int, c#1#0#0#1#1#0#1#1 : !Int].
              ( let x#c#0#0#0#1#1#0#1#0 : Int <- c#0#0#0#1#1#0#1#0.
                c#1#0#0#1#1#0#1#0 <- x#c#0#0#0#1#1#0#1#0
              | let x#c#0#0#0#1#1#0#1#1 : Int <- c#0#0#0#1#1#0#1#1.
                c#1#0#0#1#1#0#1#1 <- x#c#0#0#0#1#1#0#1#1 ))
          | split c#0#0#0#1#1#1 {c#0#0#0#1#1#1#0 : {?Int, ?Int},c#0#0#0#1#1#1#1 : {?Int, ?Int}}.
            split c#1#0#0#1#1#1 [c#1#0#0#1#1#1#0 : [!Int, !Int],c#1#0#0#1#1#1#1 : [!Int, !Int]].
            ( split c#0#0#0#1#1#1#0 {c#0#0#0#1#1#1#0#0 : ?Int, c#0#0#0#1#1#1#0#1 : ?Int}.
              split c#1#0#0#1#1#1#0 [c#1#0#0#1#1#1#0#0 : !Int, c#1#0#0#1#1#1#0#1 : !Int].
              ( let x#c#0#0#0#1#1#1#0#0 : Int <- c#0#0#0#1#1#1#0#0.
                c#1#0#0#1#1#1#0#0 <- x#c#0#0#0#1#1#1#0#0
              | let x#c#0#0#0#1#1#1#0#1 : Int <- c#0#0#0#1#1#1#0#1.
                c#1#0#0#1#1#1#0#1 <- x#c#0#0#0#1#1#1#0#1 )
            | split c#0#0#0#1#1#1#1 {c#0#0#0#1#1#1#1#0 : ?Int, c#0#0#0#1#1#1#1#1 : ?Int}.
              split c#1#0#0#1#1#1#1 [c#1#0#0#1#1#1#1#0 : !Int, c#1#0#0#1#1#1#1#1 : !Int].
              ( let x#c#0#0#0#1#1#1#1#0 : Int <- c#0#0#0#1#1#1#1#0.
                c#1#0#0#1#1#1#1#0 <- x#c#0#0#0#1#1#1#1#0
              | let x#c#0#0#0#1#1#1#1#1 : Int <- c#0#0#0#1#1#1#1#1.
                c#1#0#0#1#1#1#1#1 <- x#c#0#0#0#1#1#1#1#1 )))))
    | split c#0#0#1 {c#0#0#1#0 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, c#0#0#1#1 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}.
      split c#1#0#1 [c#1#0#1#0 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], c#1#0#1#1 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]].
      ( split c#0#0#1#0 {c#0#0#1#0#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#0#1#0#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#0#1#0 [c#1#0#1#0#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#0#1#0#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#0#1#0#0 {c#0#0#1#0#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#1#0#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#1#0#0 [c#1#0#1#0#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#1#0#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#1#0#0#0 {c#0#0#1#0#0#0#0 : {?Int, ?Int},c#0#0#1#0#0#0#1 : {?Int, ?Int}}.
            split c#1#0#1#0#0#0 [c#1#0#1#0#0#0#0 : [!Int, !Int],c#1#0#1#0#0#0#1 : [!Int, !Int]].
            ( split c#0#0#1#0#0#0#0 {c#0#0#1#0#0#0#0#0 : ?Int, c#0#0#1#0#0#0#0#1 : ?Int}.
              split c#1#0#1#0#0#0#0 [c#1#0#1#0#0#0#0#0 : !Int, c#1#0#1#0#0#0#0#1 : !Int].
              ( let x#c#0#0#1#0#0#0#0#0 : Int <- c#0#0#1#0#0#0#0#0.
                c#1#0#1#0#0#0#0#0 <- x#c#0#0#1#0#0#0#0#0
              | let x#c#0#0#1#0#0#0#0#1 : Int <- c#0#0#1#0#0#0#0#1.
                c#1#0#1#0#0#0#0#1 <- x#c#0#0#1#0#0#0#0#1 )
            | split c#0#0#1#0#0#0#1 {c#0#0#1#0#0#0#1#0 : ?Int, c#0#0#1#0#0#0#1#1 : ?Int}.
              split c#1#0#1#0#0#0#1 [c#1#0#1#0#0#0#1#0 : !Int, c#1#0#1#0#0#0#1#1 : !Int].
              ( let x#c#0#0#1#0#0#0#1#0 : Int <- c#0#0#1#0#0#0#1#0.
                c#1#0#1#0#0#0#1#0 <- x#c#0#0#1#0#0#0#1#0
              | let x#c#0#0#1#0#0#0#1#1 : Int <- c#0#0#1#0#0#0#1#1.
                c#1#0#1#0#0#0#1#1 <- x#c#0#0#1#0#0#0#1#1 ))
          | split c#0#0#1#0#0#1 {c#0#0#1#0#0#1#0 : {?Int, ?Int},c#0#0#1#0#0#1#1 : {?Int, ?Int}}.
            split c#1#0#1#0#0#1 [c#1#0#1#0#0#1#0 : [!Int, !Int],c#1#0#1#0#0#1#1 : [!Int, !Int]].
            ( split c#0#0#1#0#0#1#0 {c#0#0#1#0#0#1#0#0 : ?Int, c#0#0#1#0#0#1#0#1 : ?Int}.
              split c#1#0#1#0#0#1#0 [c#1#0#1#0#0#1#0#0 : !Int, c#1#0#1#0#0#1#0#1 : !Int].
              ( let x#c#0#0#1#0#0#1#0#0 : Int <- c#0#0#1#0#0#1#0#0.
                c#1#0#1#0#0#1#0#0 <- x#c#0#0#1#0#0#1#0#0
              | let x#c#0#0#1#0#0#1#0#1 : Int <- c#0#0#1#0#0#1#0#1.
                c#1#0#1#0#0#1#0#1 <- x#c#0#0#1#0#0#1#0#1 )
            | split c#0#0#1#0#0#1#1 {c#0#0#1#0#0#1#1#0 : ?Int, c#0#0#1#0#0#1#1#1 : ?Int}.
              split c#1#0#1#0#0#1#1 [c#1#0#1#0#0#1#1#0 : !Int, c#1#0#1#0#0#1#1#1 : !Int].
              ( let x#c#0#0#1#0#0#1#1#0 : Int <- c#0#0#1#0#0#1#1#0.
                c#1#0#1#0#0#1#1#0 <- x#c#0#0#1#0#0#1#1#0
              | let x#c#0#0#1#0#0#1#1#1 : Int <- c#0#0#1#0#0#1#1#1.
                c#1#0#1#0#0#1#1#1 <- x#c#0#0#1#0#0#1#1#1 )))
        | split c#0#0#1#0#1 {c#0#0#1#0#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#1#0#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#1#0#1 [c#1#0#1#0#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#1#0#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#1#0#1#0 {c#0#0#1#0#1#0#0 : {?Int, ?Int},c#0#0#1#0#1#0#1 : {?Int, ?Int}}.
            split c#1#0#1#0#1#0 [c#1#0#1#0#1#0#0 : [!Int, !Int],c#1#0#1#0#1#0#1 : [!Int, !Int]].
            ( split c#0#0#1#0#1#0#0 {c#0#0#1#0#1#0#0#0 : ?Int, c#0#0#1#0#1#0#0#1 : ?Int}.
              split c#1#0#1#0#1#0#0 [c#1#0#1#0#1#0#0#0 : !Int, c#1#0#1#0#1#0#0#1 : !Int].
              ( let x#c#0#0#1#0#1#0#0#0 : Int <- c#0#0#1#0#1#0#0#0.
                c#1#0#1#0#1#0#0#0 <- x#c#0#0#1#0#1#0#0#0
              | let x#c#0#0#1#0#1#0#0#1 : Int <- c#0#0#1#0#1#0#0#1.
                c#1#0#1#0#1#0#0#1 <- x#c#0#0#1#0#1#0#0#1 )
            | split c#0#0#1#0#1#0#1 {c#0#0#1#0#1#0#1#0 : ?Int, c#0#0#1#0#1#0#1#1 : ?Int}.
              split c#1#0#1#0#1#0#1 [c#1#0#1#0#1#0#1#0 : !Int, c#1#0#1#0#1#0#1#1 : !Int].
              ( let x#c#0#0#1#0#1#0#1#0 : Int <- c#0#0#1#0#1#0#1#0.
                c#1#0#1#0#1#0#1#0 <- x#c#0#0#1#0#1#0#1#0
              | let x#c#0#0#1#0#1#0#1#1 : Int <- c#0#0#1#0#1#0#1#1.
                c#1#0#1#0#1#0#1#1 <- x#c#0#0#1#0#1#0#1#1 ))
          | split c#0#0#1#0#1#1 {c#0#0#1#0#1#1#0 : {?Int, ?Int},c#0#0#1#0#1#1#1 : {?Int, ?Int}}.
            split c#1#0#1#0#1#1 [c#1#0#1#0#1#1#0 : [!Int, !Int],c#1#0#1#0#1#1#1 : [!Int, !Int]].
            ( split c#0#0#1#0#1#1#0 {c#0#0#1#0#1#1#0#0 : ?Int, c#0#0#1#0#1#1#0#1 : ?Int}.
              split c#1#0#1#0#1#1#0 [c#1#0#1#0#1#1#0#0 : !Int, c#1#0#1#0#1#1#0#1 : !Int].
              ( let x#c#0#0#1#0#1#1#0#0 : Int <- c#0#0#1#0#1#1#0#0.
                c#1#0#1#0#1#1#0#0 <- x#c#0#0#1#0#1#1#0#0
              | let x#c#0#0#1#0#1#1#0#1 : Int <- c#0#0#1#0#1#1#0#1.
                c#1#0#1#0#1#1#0#1 <- x#c#0#0#1#0#1#1#0#1 )
            | split c#0#0#1#0#1#1#1 {c#0#0#1#0#1#1#1#0 : ?Int, c#0#0#1#0#1#1#1#1 : ?Int}.
              split c#1#0#1#0#1#1#1 [c#1#0#1#0#1#1#1#0 : !Int, c#1#0#1#0#1#1#1#1 : !Int].
              ( let x#c#0#0#1#0#1#1#1#0 : Int <- c#0#0#1#0#1#1#1#0.
                c#1#0#1#0#1#1#1#0 <- x#c#0#0#1#0#1#1#1#0
              | let x#c#0#0#1#0#1#1#1#1 : Int <- c#0#0#1#0#1#1#1#1.
                c#1#0#1#0#1#1#1#1 <- x#c#0#0#1#0#1#1#1#1 ))))
      | split c#0#0#1#1 {c#0#0#1#1#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#0#1#1#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#0#1#1 [c#1#0#1#1#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#0#1#1#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#0#1#1#0 {c#0#0#1#1#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#1#1#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#1#1#0 [c#1#0#1#1#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#1#1#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#1#1#0#0 {c#0#0#1#1#0#0#0 : {?Int, ?Int},c#0#0#1#1#0#0#1 : {?Int, ?Int}}.
            split c#1#0#1#1#0#0 [c#1#0#1#1#0#0#0 : [!Int, !Int],c#1#0#1#1#0#0#1 : [!Int, !Int]].
            ( split c#0#0#1#1#0#0#0 {c#0#0#1#1#0#0#0#0 : ?Int, c#0#0#1#1#0#0#0#1 : ?Int}.
              split c#1#0#1#1#0#0#0 [c#1#0#1#1#0#0#0#0 : !Int, c#1#0#1#1#0#0#0#1 : !Int].
              ( let x#c#0#0#1#1#0#0#0#0 : Int <- c#0#0#1#1#0#0#0#0.
                c#1#0#1#1#0#0#0#0 <- x#c#0#0#1#1#0#0#0#0
              | let x#c#0#0#1#1#0#0#0#1 : Int <- c#0#0#1#1#0#0#0#1.
                c#1#0#1#1#0#0#0#1 <- x#c#0#0#1#1#0#0#0#1 )
            | split c#0#0#1#1#0#0#1 {c#0#0#1#1#0#0#1#0 : ?Int, c#0#0#1#1#0#0#1#1 : ?Int}.
              split c#1#0#1#1#0#0#1 [c#1#0#1#1#0#0#1#0 : !Int, c#1#0#1#1#0#0#1#1 : !Int].
              ( let x#c#0#0#1#1#0#0#1#0 : Int <- c#0#0#1#1#0#0#1#0.
                c#1#0#1#1#0#0#1#0 <- x#c#0#0#1#1#0#0#1#0
              | let x#c#0#0#1#1#0#0#1#1 : Int <- c#0#0#1#1#0#0#1#1.
                c#1#0#1#1#0#0#1#1 <- x#c#0#0#1#1#0#0#1#1 ))
          | split c#0#0#1#1#0#1 {c#0#0#1#1#0#1#0 : {?Int, ?Int},c#0#0#1#1#0#1#1 : {?Int, ?Int}}.
            split c#1#0#1#1#0#1 [c#1#0#1#1#0#1#0 : [!Int, !Int],c#1#0#1#1#0#1#1 : [!Int, !Int]].
            ( split c#0#0#1#1#0#1#0 {c#0#0#1#1#0#1#0#0 : ?Int, c#0#0#1#1#0#1#0#1 : ?Int}.
              split c#1#0#1#1#0#1#0 [c#1#0#1#1#0#1#0#0 : !Int, c#1#0#1#1#0#1#0#1 : !Int].
              ( let x#c#0#0#1#1#0#1#0#0 : Int <- c#0#0#1#1#0#1#0#0.
                c#1#0#1#1#0#1#0#0 <- x#c#0#0#1#1#0#1#0#0
              | let x#c#0#0#1#1#0#1#0#1 : Int <- c#0#0#1#1#0#1#0#1.
                c#1#0#1#1#0#1#0#1 <- x#c#0#0#1#1#0#1#0#1 )
            | split c#0#0#1#1#0#1#1 {c#0#0#1#1#0#1#1#0 : ?Int, c#0#0#1#1#0#1#1#1 : ?Int}.
              split c#1#0#1#1#0#1#1 [c#1#0#1#1#0#1#1#0 : !Int, c#1#0#1#1#0#1#1#1 : !Int].
              ( let x#c#0#0#1#1#0#1#1#0 : Int <- c#0#0#1#1#0#1#1#0.
                c#1#0#1#1#0#1#1#0 <- x#c#0#0#1#1#0#1#1#0
              | let x#c#0#0#1#1#0#1#1#1 : Int <- c#0#0#1#1#0#1#1#1.
                c#1#0#1#1#0#1#1#1 <- x#c#0#0#1#1#0#1#1#1 )))
        | split c#0#0#1#1#1 {c#0#0#1#1#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#0#1#1#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#0#1#1#1 [c#1#0#1#1#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#0#1#1#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#0#1#1#1#0 {c#0#0#1#1#1#0#0 : {?Int, ?Int},c#0#0#1#1#1#0#1 : {?Int, ?Int}}.
            split c#1#0#1#1#1#0 [c#1#0#1#1#1#0#0 : [!Int, !Int],c#1#0#1#1#1#0#1 : [!Int, !Int]].
            ( split c#0#0#1#1#1#0#0 {c#0#0#1#1#1#0#0#0 : ?Int, c#0#0#1#1#1#0#0#1 : ?Int}.
              split c#1#0#1#1#1#0#0 [c#1#0#1#1#1#0#0#0 : !Int, c#1#0#1#1#1#0#0#1 : !Int].
              ( let x#c#0#0#1#1#1#0#0#0 : Int <- c#0#0#1#1#1#0#0#0.
                c#1#0#1#1#1#0#0#0 <- x#c#0#0#1#1#1#0#0#0
              | let x#c#0#0#1#1#1#0#0#1 : Int <- c#0#0#1#1#1#0#0#1.
                c#1#0#1#1#1#0#0#1 <- x#c#0#0#1#1#1#0#0#1 )
            | split c#0#0#1#1#1#0#1 {c#0#0#1#1#1#0#1#0 : ?Int, c#0#0#1#1#1#0#1#1 : ?Int}.
              split c#1#0#1#1#1#0#1 [c#1#0#1#1#1#0#1#0 : !Int, c#1#0#1#1#1#0#1#1 : !Int].
              ( let x#c#0#0#1#1#1#0#1#0 : Int <- c#0#0#1#1#1#0#1#0.
                c#1#0#1#1#1#0#1#0 <- x#c#0#0#1#1#1#0#1#0
              | let x#c#0#0#1#1#1#0#1#1 : Int <- c#0#0#1#1#1#0#1#1.
                c#1#0#1#1#1#0#1#1 <- x#c#0#0#1#1#1#0#1#1 ))
          | split c#0#0#1#1#1#1 {c#0#0#1#1#1#1#0 : {?Int, ?Int},c#0#0#1#1#1#1#1 : {?Int, ?Int}}.
            split c#1#0#1#1#1#1 [c#1#0#1#1#1#1#0 : [!Int, !Int],c#1#0#1#1#1#1#1 : [!Int, !Int]].
            ( split c#0#0#1#1#1#1#0 {c#0#0#1#1#1#1#0#0 : ?Int, c#0#0#1#1#1#1#0#1 : ?Int}.
              split c#1#0#1#1#1#1#0 [c#1#0#1#1#1#1#0#0 : !Int, c#1#0#1#1#1#1#0#1 : !Int].
              ( let x#c#0#0#1#1#1#1#0#0 : Int <- c#0#0#1#1#1#1#0#0.
                c#1#0#1#1#1#1#0#0 <- x#c#0#0#1#1#1#1#0#0
              | let x#c#0#0#1#1#1#1#0#1 : Int <- c#0#0#1#1#1#1#0#1.
                c#1#0#1#1#1#1#0#1 <- x#c#0#0#1#1#1#1#0#1 )
            | split c#0#0#1#1#1#1#1 {c#0#0#1#1#1#1#1#0 : ?Int, c#0#0#1#1#1#1#1#1 : ?Int}.
              split c#1#0#1#1#1#1#1 [c#1#0#1#1#1#1#1#0 : !Int, c#1#0#1#1#1#1#1#1 : !Int].
              ( let x#c#0#0#1#1#1#1#1#0 : Int <- c#0#0#1#1#1#1#1#0.
                c#1#0#1#1#1#1#1#0 <- x#c#0#0#1#1#1#1#1#0
              | let x#c#0#0#1#1#1#1#1#1 : Int <- c#0#0#1#1#1#1#1#1.
                c#1#0#1#1#1#1#1#1 <- x#c#0#0#1#1#1#1#1#1 ))))))
  | split c#0#1 {c#0#1#0 : {{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}},c#0#1#1 : {{{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}}.
    split c#1#1 [c#1#1#0 : [[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]],c#1#1#1 : [[[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]]].
    ( split c#0#1#0 {c#0#1#0#0 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, c#0#1#0#1 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}.
      split c#1#1#0 [c#1#1#0#0 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], c#1#1#0#1 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]].
      ( split c#0#1#0#0 {c#0#1#0#0#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#1#0#0#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#1#0#0 [c#1#1#0#0#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#1#0#0#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#1#0#0#0 {c#0#1#0#0#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#0#0#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#0#0#0 [c#1#1#0#0#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#0#0#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#0#0#0#0 {c#0#1#0#0#0#0#0 : {?Int, ?Int},c#0#1#0#0#0#0#1 : {?Int, ?Int}}.
            split c#1#1#0#0#0#0 [c#1#1#0#0#0#0#0 : [!Int, !Int],c#1#1#0#0#0#0#1 : [!Int, !Int]].
            ( split c#0#1#0#0#0#0#0 {c#0#1#0#0#0#0#0#0 : ?Int, c#0#1#0#0#0#0#0#1 : ?Int}.
              split c#1#1#0#0#0#0#0 [c#1#1#0#0#0#0#0#0 : !Int, c#1#1#0#0#0#0#0#1 : !Int].
              ( let x#c#0#1#0#0#0#0#0#0 : Int <- c#0#1#0#0#0#0#0#0.
                c#1#1#0#0#0#0#0#0 <- x#c#0#1#0#0#0#0#0#0
              | let x#c#0#1#0#0#0#0#0#1 : Int <- c#0#1#0#0#0#0#0#1.
                c#1#1#0#0#0#0#0#1 <- x#c#0#1#0#0#0#0#0#1 )
            | split c#0#1#0#0#0#0#1 {c#0#1#0#0#0#0#1#0 : ?Int, c#0#1#0#0#0#0#1#1 : ?Int}.
              split c#1#1#0#0#0#0#1 [c#1#1#0#0#0#0#1#0 : !Int, c#1#1#0#0#0#0#1#1 : !Int].
              ( let x#c#0#1#0#0#0#0#1#0 : Int <- c#0#1#0#0#0#0#1#0.
                c#1#1#0#0#0#0#1#0 <- x#c#0#1#0#0#0#0#1#0
              | let x#c#0#1#0#0#0#0#1#1 : Int <- c#0#1#0#0#0#0#1#1.
                c#1#1#0#0#0#0#1#1 <- x#c#0#1#0#0#0#0#1#1 ))
          | split c#0#1#0#0#0#1 {c#0#1#0#0#0#1#0 : {?Int, ?Int},c#0#1#0#0#0#1#1 : {?Int, ?Int}}.
            split c#1#1#0#0#0#1 [c#1#1#0#0#0#1#0 : [!Int, !Int],c#1#1#0#0#0#1#1 : [!Int, !Int]].
            ( split c#0#1#0#0#0#1#0 {c#0#1#0#0#0#1#0#0 : ?Int, c#0#1#0#0#0#1#0#1 : ?Int}.
              split c#1#1#0#0#0#1#0 [c#1#1#0#0#0#1#0#0 : !Int, c#1#1#0#0#0#1#0#1 : !Int].
              ( let x#c#0#1#0#0#0#1#0#0 : Int <- c#0#1#0#0#0#1#0#0.
                c#1#1#0#0#0#1#0#0 <- x#c#0#1#0#0#0#1#0#0
              | let x#c#0#1#0#0#0#1#0#1 : Int <- c#0#1#0#0#0#1#0#1.
                c#1#1#0#0#0#1#0#1 <- x#c#0#1#0#0#0#1#0#1 )
            | split c#0#1#0#0#0#1#1 {c#0#1#0#0#0#1#1#0 : ?Int, c#0#1#0#0#0#1#1#1 : ?Int}.
              split c#1#1#0#0#0#1#1 [c#1#1#0#0#0#1#1#0 : !Int, c#1#1#0#0#0#1#1#1 : !Int].
              ( let x#c#0#1#0#0#0#1#1#0 : Int <- c#0#1#0#0#0#1#1#0.
                c#1#1#0#0#0#1#1#0 <- x#c#0#1#0#0#0#1#1#0
              | let x#c#0#1#0#0#0#1#1#1 : Int <- c#0#1#0#0#0#1#1#1.
                c#1#1#0#0#0#1#1#1 <- x#c#0#1#0#0#0#1#1#1 )))
        | split c#0#1#0#0#1 {c#0#1#0#0#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#0#0#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#0#0#1 [c#1#1#0#0#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#0#0#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#0#0#1#0 {c#0#1#0#0#1#0#0 : {?Int, ?Int},c#0#1#0#0#1#0#1 : {?Int, ?Int}}.
            split c#1#1#0#0#1#0 [c#1#1#0#0#1#0#0 : [!Int, !Int],c#1#1#0#0#1#0#1 : [!Int, !Int]].
            ( split c#0#1#0#0#1#0#0 {c#0#1#0#0#1#0#0#0 : ?Int, c#0#1#0#0#1#0#0#1 : ?Int}.
              split c#1#1#0#0#1#0#0 [c#1#1#0#0#1#0#0#0 : !Int, c#1#1#0#0#1#0#0#1 : !Int].
              ( let x#c#0#1#0#0#1#0#0#0 : Int <- c#0#1#0#0#1#0#0#0.
                c#1#1#0#0#1#0#0#0 <- x#c#0#1#0#0#1#0#0#0
              | let x#c#0#1#0#0#1#0#0#1 : Int <- c#0#1#0#0#1#0#0#1.
                c#1#1#0#0#1#0#0#1 <- x#c#0#1#0#0#1#0#0#1 )
            | split c#0#1#0#0#1#0#1 {c#0#1#0#0#1#0#1#0 : ?Int, c#0#1#0#0#1#0#1#1 : ?Int}.
              split c#1#1#0#0#1#0#1 [c#1#1#0#0#1#0#1#0 : !Int, c#1#1#0#0#1#0#1#1 : !Int].
              ( let x#c#0#1#0#0#1#0#1#0 : Int <- c#0#1#0#0#1#0#1#0.
                c#1#1#0#0#1#0#1#0 <- x#c#0#1#0#0#1#0#1#0
              | let x#c#0#1#0#0#1#0#1#1 : Int <- c#0#1#0#0#1#0#1#1.
                c#1#1#0#0#1#0#1#1 <- x#c#0#1#0#0#1#0#1#1 ))
          | split c#0#1#0#0#1#1 {c#0#1#0#0#1#1#0 : {?Int, ?Int},c#0#1#0#0#1#1#1 : {?Int, ?Int}}.
            split c#1#1#0#0#1#1 [c#1#1#0#0#1#1#0 : [!Int, !Int],c#1#1#0#0#1#1#1 : [!Int, !Int]].
            ( split c#0#1#0#0#1#1#0 {c#0#1#0#0#1#1#0#0 : ?Int, c#0#1#0#0#1#1#0#1 : ?Int}.
              split c#1#1#0#0#1#1#0 [c#1#1#0#0#1#1#0#0 : !Int, c#1#1#0#0#1#1#0#1 : !Int].
              ( let x#c#0#1#0#0#1#1#0#0 : Int <- c#0#1#0#0#1#1#0#0.
                c#1#1#0#0#1#1#0#0 <- x#c#0#1#0#0#1#1#0#0
              | let x#c#0#1#0#0#1#1#0#1 : Int <- c#0#1#0#0#1#1#0#1.
                c#1#1#0#0#1#1#0#1 <- x#c#0#1#0#0#1#1#0#1 )
            | split c#0#1#0#0#1#1#1 {c#0#1#0#0#1#1#1#0 : ?Int, c#0#1#0#0#1#1#1#1 : ?Int}.
              split c#1#1#0#0#1#1#1 [c#1#1#0#0#1#1#1#0 : !Int, c#1#1#0#0#1#1#1#1 : !Int].
              ( let x#c#0#1#0#0#1#1#1#0 : Int <- c#0#1#0#0#1#1#1#0.
                c#1#1#0#0#1#1#1#0 <- x#c#0#1#0#0#1#1#1#0
              | let x#c#0#1#0#0#1#1#1#1 : Int <- c#0#1#0#0#1#1#1#1.
                c#1#1#0#0#1#1#1#1 <- x#c#0#1#0#0#1#1#1#1 ))))
      | split c#0#1#0#1 {c#0#1#0#1#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#1#0#1#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#1#0#1 [c#1#1#0#1#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#1#0#1#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#1#0#1#0 {c#0#1#0#1#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#0#1#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#0#1#0 [c#1#1#0#1#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#0#1#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#0#1#0#0 {c#0#1#0#1#0#0#0 : {?Int, ?Int},c#0#1#0#1#0#0#1 : {?Int, ?Int}}.
            split c#1#1#0#1#0#0 [c#1#1#0#1#0#0#0 : [!Int, !Int],c#1#1#0#1#0#0#1 : [!Int, !Int]].
            ( split c#0#1#0#1#0#0#0 {c#0#1#0#1#0#0#0#0 : ?Int, c#0#1#0#1#0#0#0#1 : ?Int}.
              split c#1#1#0#1#0#0#0 [c#1#1#0#1#0#0#0#0 : !Int, c#1#1#0#1#0#0#0#1 : !Int].
              ( let x#c#0#1#0#1#0#0#0#0 : Int <- c#0#1#0#1#0#0#0#0.
                c#1#1#0#1#0#0#0#0 <- x#c#0#1#0#1#0#0#0#0
              | let x#c#0#1#0#1#0#0#0#1 : Int <- c#0#1#0#1#0#0#0#1.
                c#1#1#0#1#0#0#0#1 <- x#c#0#1#0#1#0#0#0#1 )
            | split c#0#1#0#1#0#0#1 {c#0#1#0#1#0#0#1#0 : ?Int, c#0#1#0#1#0#0#1#1 : ?Int}.
              split c#1#1#0#1#0#0#1 [c#1#1#0#1#0#0#1#0 : !Int, c#1#1#0#1#0#0#1#1 : !Int].
              ( let x#c#0#1#0#1#0#0#1#0 : Int <- c#0#1#0#1#0#0#1#0.
                c#1#1#0#1#0#0#1#0 <- x#c#0#1#0#1#0#0#1#0
              | let x#c#0#1#0#1#0#0#1#1 : Int <- c#0#1#0#1#0#0#1#1.
                c#1#1#0#1#0#0#1#1 <- x#c#0#1#0#1#0#0#1#1 ))
          | split c#0#1#0#1#0#1 {c#0#1#0#1#0#1#0 : {?Int, ?Int},c#0#1#0#1#0#1#1 : {?Int, ?Int}}.
            split c#1#1#0#1#0#1 [c#1#1#0#1#0#1#0 : [!Int, !Int],c#1#1#0#1#0#1#1 : [!Int, !Int]].
            ( split c#0#1#0#1#0#1#0 {c#0#1#0#1#0#1#0#0 : ?Int, c#0#1#0#1#0#1#0#1 : ?Int}.
              split c#1#1#0#1#0#1#0 [c#1#1#0#1#0#1#0#0 : !Int, c#1#1#0#1#0#1#0#1 : !Int].
              ( let x#c#0#1#0#1#0#1#0#0 : Int <- c#0#1#0#1#0#1#0#0.
                c#1#1#0#1#0#1#0#0 <- x#c#0#1#0#1#0#1#0#0
              | let x#c#0#1#0#1#0#1#0#1 : Int <- c#0#1#0#1#0#1#0#1.
                c#1#1#0#1#0#1#0#1 <- x#c#0#1#0#1#0#1#0#1 )
            | split c#0#1#0#1#0#1#1 {c#0#1#0#1#0#1#1#0 : ?Int, c#0#1#0#1#0#1#1#1 : ?Int}.
              split c#1#1#0#1#0#1#1 [c#1#1#0#1#0#1#1#0 : !Int, c#1#1#0#1#0#1#1#1 : !Int].
              ( let x#c#0#1#0#1#0#1#1#0 : Int <- c#0#1#0#1#0#1#1#0.
                c#1#1#0#1#0#1#1#0 <- x#c#0#1#0#1#0#1#1#0
              | let x#c#0#1#0#1#0#1#1#1 : Int <- c#0#1#0#1#0#1#1#1.
                c#1#1#0#1#0#1#1#1 <- x#c#0#1#0#1#0#1#1#1 )))
        | split c#0#1#0#1#1 {c#0#1#0#1#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#0#1#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#0#1#1 [c#1#1#0#1#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#0#1#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#0#1#1#0 {c#0#1#0#1#1#0#0 : {?Int, ?Int},c#0#1#0#1#1#0#1 : {?Int, ?Int}}.
            split c#1#1#0#1#1#0 [c#1#1#0#1#1#0#0 : [!Int, !Int],c#1#1#0#1#1#0#1 : [!Int, !Int]].
            ( split c#0#1#0#1#1#0#0 {c#0#1#0#1#1#0#0#0 : ?Int, c#0#1#0#1#1#0#0#1 : ?Int}.
              split c#1#1#0#1#1#0#0 [c#1#1#0#1#1#0#0#0 : !Int, c#1#1#0#1#1#0#0#1 : !Int].
              ( let x#c#0#1#0#1#1#0#0#0 : Int <- c#0#1#0#1#1#0#0#0.
                c#1#1#0#1#1#0#0#0 <- x#c#0#1#0#1#1#0#0#0
              | let x#c#0#1#0#1#1#0#0#1 : Int <- c#0#1#0#1#1#0#0#1.
                c#1#1#0#1#1#0#0#1 <- x#c#0#1#0#1#1#0#0#1 )
            | split c#0#1#0#1#1#0#1 {c#0#1#0#1#1#0#1#0 : ?Int, c#0#1#0#1#1#0#1#1 : ?Int}.
              split c#1#1#0#1#1#0#1 [c#1#1#0#1#1#0#1#0 : !Int, c#1#1#0#1#1#0#1#1 : !Int].
              ( let x#c#0#1#0#1#1#0#1#0 : Int <- c#0#1#0#1#1#0#1#0.
                c#1#1#0#1#1#0#1#0 <- x#c#0#1#0#1#1#0#1#0
              | let x#c#0#1#0#1#1#0#1#1 : Int <- c#0#1#0#1#1#0#1#1.
                c#1#1#0#1#1#0#1#1 <- x#c#0#1#0#1#1#0#1#1 ))
          | split c#0#1#0#1#1#1 {c#0#1#0#1#1#1#0 : {?Int, ?Int},c#0#1#0#1#1#1#1 : {?Int, ?Int}}.
            split c#1#1#0#1#1#1 [c#1#1#0#1#1#1#0 : [!Int, !Int],c#1#1#0#1#1#1#1 : [!Int, !Int]].
            ( split c#0#1#0#1#1#1#0 {c#0#1#0#1#1#1#0#0 : ?Int, c#0#1#0#1#1#1#0#1 : ?Int}.
              split c#1#1#0#1#1#1#0 [c#1#1#0#1#1#1#0#0 : !Int, c#1#1#0#1#1#1#0#1 : !Int].
              ( let x#c#0#1#0#1#1#1#0#0 : Int <- c#0#1#0#1#1#1#0#0.
                c#1#1#0#1#1#1#0#0 <- x#c#0#1#0#1#1#1#0#0
              | let x#c#0#1#0#1#1#1#0#1 : Int <- c#0#1#0#1#1#1#0#1.
                c#1#1#0#1#1#1#0#1 <- x#c#0#1#0#1#1#1#0#1 )
            | split c#0#1#0#1#1#1#1 {c#0#1#0#1#1#1#1#0 : ?Int, c#0#1#0#1#1#1#1#1 : ?Int}.
              split c#1#1#0#1#1#1#1 [c#1#1#0#1#1#1#1#0 : !Int, c#1#1#0#1#1#1#1#1 : !Int].
              ( let x#c#0#1#0#1#1#1#1#0 : Int <- c#0#1#0#1#1#1#1#0.
                c#1#1#0#1#1#1#1#0 <- x#c#0#1#0#1#1#1#1#0
              | let x#c#0#1#0#1#1#1#1#1 : Int <- c#0#1#0#1#1#1#1#1.
                c#1#1#0#1#1#1#1#1 <- x#c#0#1#0#1#1#1#1#1 )))))
    | split c#0#1#1 {c#0#1#1#0 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}, c#0#1#1#1 : {{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},{{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}}.
      split c#1#1#1 [c#1#1#1#0 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]], c#1#1#1#1 : [[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],[[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]]].
      ( split c#0#1#1#0 {c#0#1#1#0#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#1#1#0#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#1#1#0 [c#1#1#1#0#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#1#1#0#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#1#1#0#0 {c#0#1#1#0#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#1#0#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#1#0#0 [c#1#1#1#0#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#1#0#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#1#0#0#0 {c#0#1#1#0#0#0#0 : {?Int, ?Int},c#0#1#1#0#0#0#1 : {?Int, ?Int}}.
            split c#1#1#1#0#0#0 [c#1#1#1#0#0#0#0 : [!Int, !Int],c#1#1#1#0#0#0#1 : [!Int, !Int]].
            ( split c#0#1#1#0#0#0#0 {c#0#1#1#0#0#0#0#0 : ?Int, c#0#1#1#0#0#0#0#1 : ?Int}.
              split c#1#1#1#0#0#0#0 [c#1#1#1#0#0#0#0#0 : !Int, c#1#1#1#0#0#0#0#1 : !Int].
              ( let x#c#0#1#1#0#0#0#0#0 : Int <- c#0#1#1#0#0#0#0#0.
                c#1#1#1#0#0#0#0#0 <- x#c#0#1#1#0#0#0#0#0
              | let x#c#0#1#1#0#0#0#0#1 : Int <- c#0#1#1#0#0#0#0#1.
                c#1#1#1#0#0#0#0#1 <- x#c#0#1#1#0#0#0#0#1 )
            | split c#0#1#1#0#0#0#1 {c#0#1#1#0#0#0#1#0 : ?Int, c#0#1#1#0#0#0#1#1 : ?Int}.
              split c#1#1#1#0#0#0#1 [c#1#1#1#0#0#0#1#0 : !Int, c#1#1#1#0#0#0#1#1 : !Int].
              ( let x#c#0#1#1#0#0#0#1#0 : Int <- c#0#1#1#0#0#0#1#0.
                c#1#1#1#0#0#0#1#0 <- x#c#0#1#1#0#0#0#1#0
              | let x#c#0#1#1#0#0#0#1#1 : Int <- c#0#1#1#0#0#0#1#1.
                c#1#1#1#0#0#0#1#1 <- x#c#0#1#1#0#0#0#1#1 ))
          | split c#0#1#1#0#0#1 {c#0#1#1#0#0#1#0 : {?Int, ?Int},c#0#1#1#0#0#1#1 : {?Int, ?Int}}.
            split c#1#1#1#0#0#1 [c#1#1#1#0#0#1#0 : [!Int, !Int],c#1#1#1#0#0#1#1 : [!Int, !Int]].
            ( split c#0#1#1#0#0#1#0 {c#0#1#1#0#0#1#0#0 : ?Int, c#0#1#1#0#0#1#0#1 : ?Int}.
              split c#1#1#1#0#0#1#0 [c#1#1#1#0#0#1#0#0 : !Int, c#1#1#1#0#0#1#0#1 : !Int].
              ( let x#c#0#1#1#0#0#1#0#0 : Int <- c#0#1#1#0#0#1#0#0.
                c#1#1#1#0#0#1#0#0 <- x#c#0#1#1#0#0#1#0#0
              | let x#c#0#1#1#0#0#1#0#1 : Int <- c#0#1#1#0#0#1#0#1.
                c#1#1#1#0#0#1#0#1 <- x#c#0#1#1#0#0#1#0#1 )
            | split c#0#1#1#0#0#1#1 {c#0#1#1#0#0#1#1#0 : ?Int, c#0#1#1#0#0#1#1#1 : ?Int}.
              split c#1#1#1#0#0#1#1 [c#1#1#1#0#0#1#1#0 : !Int, c#1#1#1#0#0#1#1#1 : !Int].
              ( let x#c#0#1#1#0#0#1#1#0 : Int <- c#0#1#1#0#0#1#1#0.
                c#1#1#1#0#0#1#1#0 <- x#c#0#1#1#0#0#1#1#0
              | let x#c#0#1#1#0#0#1#1#1 : Int <- c#0#1#1#0#0#1#1#1.
                c#1#1#1#0#0#1#1#1 <- x#c#0#1#1#0#0#1#1#1 )))
        | split c#0#1#1#0#1 {c#0#1#1#0#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#1#0#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#1#0#1 [c#1#1#1#0#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#1#0#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#1#0#1#0 {c#0#1#1#0#1#0#0 : {?Int, ?Int},c#0#1#1#0#1#0#1 : {?Int, ?Int}}.
            split c#1#1#1#0#1#0 [c#1#1#1#0#1#0#0 : [!Int, !Int],c#1#1#1#0#1#0#1 : [!Int, !Int]].
            ( split c#0#1#1#0#1#0#0 {c#0#1#1#0#1#0#0#0 : ?Int, c#0#1#1#0#1#0#0#1 : ?Int}.
              split c#1#1#1#0#1#0#0 [c#1#1#1#0#1#0#0#0 : !Int, c#1#1#1#0#1#0#0#1 : !Int].
              ( let x#c#0#1#1#0#1#0#0#0 : Int <- c#0#1#1#0#1#0#0#0.
                c#1#1#1#0#1#0#0#0 <- x#c#0#1#1#0#1#0#0#0
              | let x#c#0#1#1#0#1#0#0#1 : Int <- c#0#1#1#0#1#0#0#1.
                c#1#1#1#0#1#0#0#1 <- x#c#0#1#1#0#1#0#0#1 )
            | split c#0#1#1#0#1#0#1 {c#0#1#1#0#1#0#1#0 : ?Int, c#0#1#1#0#1#0#1#1 : ?Int}.
              split c#1#1#1#0#1#0#1 [c#1#1#1#0#1#0#1#0 : !Int, c#1#1#1#0#1#0#1#1 : !Int].
              ( let x#c#0#1#1#0#1#0#1#0 : Int <- c#0#1#1#0#1#0#1#0.
                c#1#1#1#0#1#0#1#0 <- x#c#0#1#1#0#1#0#1#0
              | let x#c#0#1#1#0#1#0#1#1 : Int <- c#0#1#1#0#1#0#1#1.
                c#1#1#1#0#1#0#1#1 <- x#c#0#1#1#0#1#0#1#1 ))
          | split c#0#1#1#0#1#1 {c#0#1#1#0#1#1#0 : {?Int, ?Int},c#0#1#1#0#1#1#1 : {?Int, ?Int}}.
            split c#1#1#1#0#1#1 [c#1#1#1#0#1#1#0 : [!Int, !Int],c#1#1#1#0#1#1#1 : [!Int, !Int]].
            ( split c#0#1#1#0#1#1#0 {c#0#1#1#0#1#1#0#0 : ?Int, c#0#1#1#0#1#1#0#1 : ?Int}.
              split c#1#1#1#0#1#1#0 [c#1#1#1#0#1#1#0#0 : !Int, c#1#1#1#0#1#1#0#1 : !Int].
              ( let x#c#0#1#1#0#1#1#0#0 : Int <- c#0#1#1#0#1#1#0#0.
                c#1#1#1#0#1#1#0#0 <- x#c#0#1#1#0#1#1#0#0
              | let x#c#0#1#1#0#1#1#0#1 : Int <- c#0#1#1#0#1#1#0#1.
                c#1#1#1#0#1#1#0#1 <- x#c#0#1#1#0#1#1#0#1 )
            | split c#0#1#1#0#1#1#1 {c#0#1#1#0#1#1#1#0 : ?Int, c#0#1#1#0#1#1#1#1 : ?Int}.
              split c#1#1#1#0#1#1#1 [c#1#1#1#0#1#1#1#0 : !Int, c#1#1#1#0#1#1#1#1 : !Int].
              ( let x#c#0#1#1#0#1#1#1#0 : Int <- c#0#1#1#0#1#1#1#0.
                c#1#1#1#0#1#1#1#0 <- x#c#0#1#1#0#1#1#1#0
              | let x#c#0#1#1#0#1#1#1#1 : Int <- c#0#1#1#0#1#1#1#1.
                c#1#1#1#0#1#1#1#1 <- x#c#0#1#1#0#1#1#1#1 ))))
      | split c#0#1#1#1 {c#0#1#1#1#0 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}},c#0#1#1#1#1 : {{{?Int, ?Int},{?Int, ?Int}}, {{?Int, ?Int},{?Int, ?Int}}}}.
        split c#1#1#1#1 [c#1#1#1#1#0 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]],c#1#1#1#1#1 : [[[!Int, !Int],[!Int, !Int]], [[!Int, !Int],[!Int, !Int]]]].
        ( split c#0#1#1#1#0 {c#0#1#1#1#0#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#1#1#0#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#1#1#0 [c#1#1#1#1#0#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#1#1#0#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#1#1#0#0 {c#0#1#1#1#0#0#0 : {?Int, ?Int},c#0#1#1#1#0#0#1 : {?Int, ?Int}}.
            split c#1#1#1#1#0#0 [c#1#1#1#1#0#0#0 : [!Int, !Int],c#1#1#1#1#0#0#1 : [!Int, !Int]].
            ( split c#0#1#1#1#0#0#0 {c#0#1#1#1#0#0#0#0 : ?Int, c#0#1#1#1#0#0#0#1 : ?Int}.
              split c#1#1#1#1#0#0#0 [c#1#1#1#1#0#0#0#0 : !Int, c#1#1#1#1#0#0#0#1 : !Int].
              ( let x#c#0#1#1#1#0#0#0#0 : Int <- c#0#1#1#1#0#0#0#0.
                c#1#1#1#1#0#0#0#0 <- x#c#0#1#1#1#0#0#0#0
              | let x#c#0#1#1#1#0#0#0#1 : Int <- c#0#1#1#1#0#0#0#1.
                c#1#1#1#1#0#0#0#1 <- x#c#0#1#1#1#0#0#0#1 )
            | split c#0#1#1#1#0#0#1 {c#0#1#1#1#0#0#1#0 : ?Int, c#0#1#1#1#0#0#1#1 : ?Int}.
              split c#1#1#1#1#0#0#1 [c#1#1#1#1#0#0#1#0 : !Int, c#1#1#1#1#0#0#1#1 : !Int].
              ( let x#c#0#1#1#1#0#0#1#0 : Int <- c#0#1#1#1#0#0#1#0.
                c#1#1#1#1#0#0#1#0 <- x#c#0#1#1#1#0#0#1#0
              | let x#c#0#1#1#1#0#0#1#1 : Int <- c#0#1#1#1#0#0#1#1.
                c#1#1#1#1#0#0#1#1 <- x#c#0#1#1#1#0#0#1#1 ))
          | split c#0#1#1#1#0#1 {c#0#1#1#1#0#1#0 : {?Int, ?Int},c#0#1#1#1#0#1#1 : {?Int, ?Int}}.
            split c#1#1#1#1#0#1 [c#1#1#1#1#0#1#0 : [!Int, !Int],c#1#1#1#1#0#1#1 : [!Int, !Int]].
            ( split c#0#1#1#1#0#1#0 {c#0#1#1#1#0#1#0#0 : ?Int, c#0#1#1#1#0#1#0#1 : ?Int}.
              split c#1#1#1#1#0#1#0 [c#1#1#1#1#0#1#0#0 : !Int, c#1#1#1#1#0#1#0#1 : !Int].
              ( let x#c#0#1#1#1#0#1#0#0 : Int <- c#0#1#1#1#0#1#0#0.
                c#1#1#1#1#0#1#0#0 <- x#c#0#1#1#1#0#1#0#0
              | let x#c#0#1#1#1#0#1#0#1 : Int <- c#0#1#1#1#0#1#0#1.
                c#1#1#1#1#0#1#0#1 <- x#c#0#1#1#1#0#1#0#1 )
            | split c#0#1#1#1#0#1#1 {c#0#1#1#1#0#1#1#0 : ?Int, c#0#1#1#1#0#1#1#1 : ?Int}.
              split c#1#1#1#1#0#1#1 [c#1#1#1#1#0#1#1#0 : !Int, c#1#1#1#1#0#1#1#1 : !Int].
              ( let x#c#0#1#1#1#0#1#1#0 : Int <- c#0#1#1#1#0#1#1#0.
                c#1#1#1#1#0#1#1#0 <- x#c#0#1#1#1#0#1#1#0
              | let x#c#0#1#1#1#0#1#1#1 : Int <- c#0#1#1#1#0#1#1#1.
                c#1#1#1#1#0#1#1#1 <- x#c#0#1#1#1#0#1#1#1 )))
        | split c#0#1#1#1#1 {c#0#1#1#1#1#0 : {{?Int, ?Int},{?Int, ?Int}}, c#0#1#1#1#1#1 : {{?Int, ?Int},{?Int, ?Int}}}.
          split c#1#1#1#1#1 [c#1#1#1#1#1#0 : [[!Int, !Int],[!Int, !Int]], c#1#1#1#1#1#1 : [[!Int, !Int],[!Int, !Int]]].
          ( split c#0#1#1#1#1#0 {c#0#1#1#1#1#0#0 : {?Int, ?Int},c#0#1#1#1#1#0#1 : {?Int, ?Int}}.
            split c#1#1#1#1#1#0 [c#1#1#1#1#1#0#0 : [!Int, !Int],c#1#1#1#1#1#0#1 : [!Int, !Int]].
            ( split c#0#1#1#1#1#0#0 {c#0#1#1#1#1#0#0#0 : ?Int, c#0#1#1#1#1#0#0#1 : ?Int}.
              split c#1#1#1#1#1#0#0 [c#1#1#1#1#1#0#0#0 : !Int, c#1#1#1#1#1#0#0#1 : !Int].
              ( let x#c#0#1#1#1#1#0#0#0 : Int <- c#0#1#1#1#1#0#0#0.
                c#1#1#1#1#1#0#0#0 <- x#c#0#1#1#1#1#0#0#0
              | let x#c#0#1#1#1#1#0#0#1 : Int <- c#0#1#1#1#1#0#0#1.
                c#1#1#1#1#1#0#0#1 <- x#c#0#1#1#1#1#0#0#1 )
            | split c#0#1#1#1#1#0#1 {c#0#1#1#1#1#0#1#0 : ?Int, c#0#1#1#1#1#0#1#1 : ?Int}.
              split c#1#1#1#1#1#0#1 [c#1#1#1#1#1#0#1#0 : !Int, c#1#1#1#1#1#0#1#1 : !Int].
              ( let x#c#0#1#1#1#1#0#1#0 : Int <- c#0#1#1#1#1#0#1#0.
                c#1#1#1#1#1#0#1#0 <- x#c#0#1#1#1#1#0#1#0
              | let x#c#0#1#1#1#1#0#1#1 : Int <- c#0#1#1#1#1#0#1#1.
                c#1#1#1#1#1#0#1#1 <- x#c#0#1#1#1#1#0#1#1 ))
          | split c#0#1#1#1#1#1 {c#0#1#1#1#1#1#0 : {?Int, ?Int},c#0#1#1#1#1#1#1 : {?Int, ?Int}}.
            split c#1#1#1#1#1#1 [c#1#1#1#1#1#1#0 : [!Int, !Int],c#1#1#1#1#1#1#1 : [!Int, !Int]].
            ( split c#0#1#1#1#1#1#0 {c#0#1#1#1#1#1#0#0 : ?Int, c#0#1#1#1#1#1#0#1 : ?Int}.
              split c#1#1#1#1#1#1#0 [c#1#1#1#1#1#1#0#0 : !Int, c#1#1#1#1#1#1#0#1 : !Int].
              ( let x#c#0#1#1#1#1#1#0#0 : Int <- c#0#1#1#1#1#1#0#0.
                c#1#1#1#1#1#1#0#0 <- x#c#0#1#1#1#1#1#0#0
              | let x#c#0#1#1#1#1#1#0#1 : Int <- c#0#1#1#1#1#1#0#1.
                c#1#1#1#1#1#1#0#1 <- x#c#0#1#1#1#1#1#0#1 )
            | split c#0#1#1#1#1#1#1 {c#0#1#1#1#1#1#1#0 : ?Int, c#0#1#1#1#1#1#1#1 : ?Int}.
              split c#1#1#1#1#1#1#1 [c#1#1#1#1#1#1#1#0 : !Int, c#1#1#1#1#1#1#1#1 : !Int].
              ( let x#c#0#1#1#1#1#1#1#0 : Int <- c#0#1#1#1#1#1#1#0.
                c#1#1#1#1#1#1#1#0 <- x#c#0#1#1#1#1#1#1#0
              | let x#c#0#1#1#1#1#1#1#1 : Int <- c#0#1#1#1#1#1#1#1.
                c#1#1#1#1#1#1#1#1 <- x#c#0#1#1#1#1#1#1#1 )))))))

lettype : (P : (A : Type)-> (B : Type)-> Type)-> (p : (A : Type)-> P A A)-> (A : Type)-> P (P (P (P A A)(P A A)) (P (P A A)(P A A)))(P (P (P A A)(P A A)) (P (P A A)(P A A)))=
  \ (P : (A : Type)-> (B : Type)-> Type)-> \ (p : (A : Type)-> P A A)-> \ (A : Type)-> p (P (P (P A A)(P A A)) (P (P A A)(P A A)))

assert
  1
  =
  1
  : Int

showMult =
  \ (m : Int)-> \ (n : Int)-> (showInt m)++S " * " ++S (showInt n)++S " = " ++S showInt (m * n)

showDiv =
  \ (m : Double)-> \ (n : Double)-> (showDouble m)++S " / " ++S (showDouble n)++S " = " ++S showDouble (m /D n)

my42 : String =
  "2 * 21 = 42"

my3_14 : String =
  "6.28 / 2.0 = 3.14"

myNewline : Char =
  '\n'

mkfwd =
  \ (A : Session)-> proc (a : A, na : ~ A)
  fwd A (a, na)

loli_id : (A : Session)-> < {~ A, A}> =
  \ (A : Session)-> proc (naa : {~ A, A})
  split naa {na, a}.
  fwd (~ A)(na, a)

loli_id_SInt =
  proc (naa : {?Int, !Int})
  split naa {na, a}.
  let x#na : Int <- na.
  a <- x#na

zipWith =
  \ (A : Type)-> \ (B : Type)-> \ (C : Type)-> \ (f : (a : A)-> (b : B)-> C)-> \ (n : Int)-> proc (cas : [: ?A ^ n :], cbs : [: ?B ^ n :], ccs : [: !C ^ n :])
  split cas [: ca ^ n :].
  split cbs [: cb ^ n :].
  split ccs [: cc ^ n :].
  sequence ^ n
    (let a : A <- ca.
    let b : B <- cb.
    cc <- (f a b))

zip_multD =
  \ (n : Int)-> proc (cas : [: ?Double ^ n :], cbs : [: ?Double ^ n :], ccs : [: !Double ^ n :])
  split cas [: ca ^ n :].
  split cbs [: cb ^ n :].
  split ccs [: cc ^ n :].
  sequence ^ n
    (let a : Double <- ca.
    let b : Double <- cb.
    cc <- (a *D b))

foldl =
  \ (A : Type)-> \ (B : Type)-> \ (f : (acc : B)-> (a : A)-> B)-> \ (init : B)-> \ (n : Int)-> proc (ca : [: ?A ^ n :], cr : !B)
  new/alloc (acc :* B).
  acc <- init.
  split acc [: acci ^ n, accn :].
  split ca [: ai ^ n :].
  (sequence ^ n
    (( let a : A <- ai
    | let b : B <- acci ).
    acci <- (f b a)) ).
  let x#accn : B <- accn.
  cr <- x#accn

sumD : (n : Int)-> < [: ?Double ^ n :], !Double > =
  \ (n : Int)-> proc (ca : [: ?Double ^ n :], cr : !Double)
  new/alloc (acc :* Double).
  acc <- 0.0.
  split acc [: acci ^ n, accn :].
  split ca [: ai ^ n :].
  (sequence ^ n
    (( let a : Double <- ai
    | let b : Double <- acci ).
    acci <- (b +D a)) ).
  let x#accn : Double <- accn.
  cr <- x#accn

dotproduct =
  \ (n : Int)-> \ (ann : Allocation)-> proc (as' : [: ?Double ^ n :], bs : [: ?Double ^ n :], o : !Double)
  new/ann [: cs : [: !Double ^ n :], ds :].
  split as' [: ca ^ n :].
  split bs [: cb ^ n :].
  split cs [: cc ^ n :].
  (sequence ^ n
    (let a : Double <- ca.
    let b : Double <- cb.
    cc <- (a *D b)) ).
  new/alloc (acc :* Double).
  acc <- 0.0.
  split acc [: acci ^ n, accn :].
  split ds [: ai ^ n :].
  (sequence ^ n
    (( let a : Double <- ai
    | let b : Double <- acci ).
    acci <- (b +D a)) ).
  let x#accn : Double <- accn.
  o <- x#accn

dotproduct_4_alloc =
  proc (as' : [: ?Double ^ 4 :], bs : [: ?Double ^ 4 :], o : !Double)
  new/alloc [: cs : [: !Double ^ 4 :], ds :].
  split as' [: ca ^ 4 :].
  split bs [: cb ^ 4 :].
  split cs [: cc ^ 4 :].
  (sequence ^ 4
    (let a : Double <- ca.
    let b : Double <- cb.
    cc <- (a *D b)) ).
  new/alloc (acc :* Double).
  acc <- 0.0.
  split acc [: acci ^ 4, accn :].
  split ds [: ai ^ 4 :].
  (sequence ^ 4
    (( let a : Double <- ai
    | let b : Double <- acci ).
    acci <- (b +D a)) ).
  let x#accn : Double <- accn.
  o <- x#accn

dotproduct_4_fused =
  proc (as' : [: ?Double ^ 4 :], bs : [: ?Double ^ 4 :], o : !Double)
  new/fused [: cs : [: !Double ^ 4 :], ds :].
  split as' [: ca ^ 4 :].
  split bs [: cb ^ 4 :].
  split cs [: cc ^ 4 :].
  (sequence ^ 4
    (let a : Double <- ca.
    let b : Double <- cb.
    cc <- (a *D b)) ).
  new/alloc (acc :* Double).
  acc <- 0.0.
  split acc [: acci ^ 4, accn :].
  split ds [: ai ^ 4 :].
  (sequence ^ 4
    (( let a : Double <- ai
    | let b : Double <- acci ).
    acci <- (b +D a)) ).
  let x#accn : Double <- accn.
  o <- x#accn

ix : (A : Type)-> (n : Int)-> (v : Vec A n)-> (i : Int)-> A

row =
  \ (A : Type)-> \ (m : Int)-> \ (n : Int)-> \ (a : Vec A (m * n)) -> \ (i : Int)-> proc (v : [: !A ^ n :])
  split v [: v_i ^ n :].
  sequence ^ n with j
    v_i <- (ix A (m * n)a ((i * n)+ j))

col =
  \ (A : Type)-> \ (m : Int)-> \ (n : Int)-> \ (a : Vec A (m * n)) -> \ (j : Int)-> proc (v : [: !A ^ m :])
  split v [: v_j ^ m :].
  sequence ^ m with i
    v_j <- (ix A (m * n)a ((i * n)+ j))

matmult =
  \ (m : Int)-> \ (n : Int)-> \ (p : Int)-> \ (ann0 : Allocation)-> \ (ann1 : Allocation)-> \ (ann2 : Allocation)-> proc (a : ?Vec Double (m * n),b : ?Vec Double (n * p),c : [: !Double ^ (m * p):])
  let a' : Vec Double (m * n)<- a.
  let b' : Vec Double (n * p)<- b.
  split c [: c_i_j ^ (m * p):].
  sequence ^ (m * p)with ij
    (new/ann0 [: u : [: !Double ^ n :], u' :].
    split u [: v_i ^ n :].
    (sequence ^ n with j
      v_i <- (ix Double (m * n)a' (((ij / n)* n)+ j)) ).
    new/ann1 [: v : [: !Double ^ n :], v' :].
    split v [: v_j ^ p :].
    (sequence ^ p with i
      v_j <- (ix Double (p * p)b' ((i * p)+ ij % n)) ).
    new/ann2 [: cs : [: !Double ^ n :], ds :].
    split u' [: ca ^ n :].
    split v' [: cb ^ n :].
    split cs [: cc ^ n :].
    (sequence ^ n
      (let a : Double <- ca.
      let b : Double <- cb.
      cc <- (a *D b)) ).
    new/alloc (acc :* Double).
    acc <- 0.0.
    split acc [: acci ^ n, accn :].
    split ds [: ai ^ n :].
    (sequence ^ n
      (( let a : Double <- ai
      | let b : Double <- acci ).
      acci <- (b +D a)) ).
    let x#accn : Double <- accn.
    c_i_j <- x#accn)

matmult_4_alloc =
  proc (a : ?Vec Double 16, b : ?Vec Double 16, c : [: !Double ^ 16 :])
  let a' : Vec Double 16 <- a.
  let b' : Vec Double 16 <- b.
  split c [: c_i_j ^ 16 :].
  sequence ^ 16 with ij
    (new/alloc [: u : [: !Double ^ 4 :], u' :].
    split u [: v_i ^ 4 :].
    (sequence ^ 4 with j
      v_i <- (ix Double 16 a' (((ij / 4)* 4)+ j)) ).
    new/alloc [: v : [: !Double ^ 4 :], v' :].
    split v [: v_j ^ 4 :].
    (sequence ^ 4 with i
      v_j <- (ix Double 16 b' ((i * 4)+ ij % 4)) ).
    new/alloc [: cs : [: !Double ^ 4 :], ds :].
    split u' [: ca ^ 4 :].
    split v' [: cb ^ 4 :].
    split cs [: cc ^ 4 :].
    (sequence ^ 4
      (let a : Double <- ca.
      let b : Double <- cb.
      cc <- (a *D b)) ).
    new/alloc (acc :* Double).
    acc <- 0.0.
    split acc [: acci ^ 4, accn :].
    split ds [: ai ^ 4 :].
    (sequence ^ 4
      (( let a : Double <- ai
      | let b : Double <- acci ).
      acci <- (b +D a)) ).
    let x#accn : Double <- accn.
    c_i_j <- x#accn)

merger =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : [!Vec Int m, ?Vec Int m],c1 : [!Vec Int n, ?Vec Int n],ci : ?Vec Int (m + n),co : !Vec Int (m + n))
  split c0 [c0i, c0o].
  split c1 [c1i, c1o].
  let vi : Vec Int (m + n)<- ci.
  ( c0i <- (take Int m n vi)
  | c1i <- (drop Int m n vi)
  | let v0 : Vec Int m <- c0o.
    let v1 : Vec Int n <- c1o.
    co <- (merge m n v0 v1))

merger_loli_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {[!Vec Int m.?Vec Int m, !Vec Int n.?Vec Int n],?Vec Int (m + n).!Vec Int (m + n)})
  split c {c01, d}.
  split c01 [c0, c1].
  let vi : Vec Int (m + n)<- d.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  d <- (merge m n v0 v1)

merger_nstSort_prll =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : !Vec Int m.?Vec Int m, c1 : !Vec Int n.?Vec Int n, c : ?Vec Int (m + n).!Vec Int (m + n))
  let vi : Vec Int (m + n)<- c.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  c <- (merge m n v0 v1)

merger_nstSort_prll_v2 =
  \ (m : Int)-> \ (n : Int)-> proc (c : [!Vec Int m.?Vec Int m, !Vec Int n.?Vec Int n],d : ?Vec Int (m + n).!Vec Int (m + n))
  split c [c0, c1].
  let vi : Vec Int (m + n)<- d.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  d <- (merge m n v0 v1)

merger_ParSort_full_prll =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : [!Vec Int m, ?Vec Int m],c1 : [!Vec Int n, ?Vec Int n],c : {?Vec Int (m + n),!Vec Int (m + n)})
  split c0 [c0i, c0o].
  split c1 [c1i, c1o].
  split c {ci, co}.
  let vi : Vec Int (m + n)<- ci.
  ( c0i <- (take Int m n vi)
  | c1i <- (drop Int m n vi)
  | ( let v0 : Vec Int m <- c0o
    | let v1 : Vec Int n <- c1o ).
    co <- (merge m n v0 v1))

merger_seq_inferred =
  \ (m : Int)-> \ (n : Int)-> proc (c0, c1, ci, co)
  let vi : Vec Int (m + n)<- ci.
  c0 <- (take Int m n vi).
  c1 <- (drop Int m n vi).
  let v0 : Vec Int m <- c0.
  let v1 : Vec Int n <- c1.
  co <- (merge m n v0 v1)

merger_seq =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : !Vec Int m.?Vec Int m, c1 : !Vec Int n.?Vec Int n, ci : ?Vec Int (m + n),co : !Vec Int (m + n))
  let vi : Vec Int (m + n)<- ci.
  c0 <- (take Int m n vi).
  c1 <- (drop Int m n vi).
  let v0 : Vec Int m <- c0.
  let v1 : Vec Int n <- c1.
  co <- (merge m n v0 v1)

merger_seq_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{!Vec Int m.?Vec Int m, !Vec Int n.?Vec Int n},?Vec Int (m + n).!Vec Int (m + n)})
  split c {d, io}.
  split d {d0, d1}.
  let vi : Vec Int (m + n)<- io.
  d0 <- (take Int m n vi).
  d1 <- (drop Int m n vi).
  let v0 : Vec Int m <- d0.
  let v1 : Vec Int n <- d1.
  io <- (merge m n v0 v1)

merger_seqential_ten2_loli_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{!Vec Int m.?Vec Int m, !Vec Int n.?Vec Int n},?Vec Int (m + n).!Vec Int (m + n)})
  split c {c01, d}.
  split c01 {c0, c1}.
  let vi : Vec Int (m + n)<- d.
  c0 <- (take Int m n vi).
  c1 <- (drop Int m n vi).
  let v0 : Vec Int m <- c0.
  let v1 : Vec Int n <- c1.
  d <- (merge m n v0 v1)

merger_ten2_loli_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{!Vec Int m.?Vec Int m, !Vec Int n.?Vec Int n},?Vec Int (m + n).!Vec Int (m + n)})
  split c {c01, d}.
  split c01 {c0, c1}.
  let vi : Vec Int (m + n)<- d.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  d <- (merge m n v0 v1)

mk_new_ann =
  \ (ann : Allocation)-> \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> proc ()
  new/ann [c : S, d : ~ S].
  ( @ p (c)
  | @ q (d))

mk_new_seq =
  \ (ann : Allocation)-> \ (S : Session)-> \ (p : < Log S >)-> \ (q : < ~ Log S >)-> proc ()
  new/ann [: c : Log S, d :].
  @ p (c).
  @ q (d)

mk_par2_LR =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : {S0, S1})
  split c {c0, c1}.
  @ p0 (c0).
  @ p1 (c1)

mk_par2_prll =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : {S0, S1})
  split c {c0, c1}.
  ( @ p0 (c0)
  | @ p1 (c1))

mk_par2_RL =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : {S0, S1})
  split c {c0, c1}.
  @ p1 (c1).
  @ p0 (c0)

mkrecv =
  \ (A : Type)-> proc (a : ?A)
  let x : A <- a

mkrecvInt =
  proc (a : ?Int)
  let x : Int <- a

mksend =
  \ (A : Type)-> \ (x : A)-> proc (a : !A)
  a <- x

mksendInt42 =
  proc (a : !Int)
  a <- 42

mk_seq2 =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [: S0, S1 :])
  split c [: c0, c1 :].
  @ p0 (c0).
  @ p1 (c1)

mk_ten2_2new_2fwd =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  new [d0 : ~ S0, e0 : S0].
  new [d1 : ~ S1, e1 : S1].
  ( @ p0 (e0)
  | fwd S0 (c0, d0)
  | @ p1 (e1)
  | fwd S1 (c1, d1))

mk_tensor2 =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  ( @ p0 (c0)
  | @ p1 (c1))

assert
  ?(A : Type).?(B : Type).?(C : Type)
  =
  ?(A : Type).?(B : Type).?(C : Type)
  : Session

my_dual =
  \ (S : Session)-> ~ S

test_my_dual =
  proc (c : ?Int)
  let x : Int <- c

my_loli =
  \ (S : Session)-> \ (T : Session)-> {~ S, T}

test_my_loli =
  \ (A : Type)-> proc (c : {?A, !A})
  split c {i, o}.
  let x : A <- i.
  o <- x

new_alloc =
  proc (c : !Int)
  new/alloc [d : !Int, e].
  ( d <- 1
  | let x#e : Int <- e.
    c <- x#e )

new_fuse1_recv_send_send_recv =
  proc ()
  new/fuse 1 [d : ?Int.!Int, c : !Int.?Int].
  ( c <- 1.
    let x : Int <- c
  | let y : Int <- d.
    d <- 2 )

new_seq_par_par =
  proc ()
  new/alloc [: cd : {!Int, !Bool},ef : {?Int, ?Bool}:].
  split cd {c, d}.
  split ef {e, f}.
  c <- 1.
  d <- `true.
  let b : Bool <- f.
  let i : Int <- e

new_ten2 =
  \ (A : Session)-> \ (B : Session)-> \ (pA : < A >)-> \ (pB : < B >)-> \ (pC : < {~ A, ~ B}>)-> \ (ann : Allocation)-> proc ()
  new/ann [ab : [A, B],nab : {~ A, ~ B}].
  ( split ab [a, b].
    ( @ pA (a)
    | @ pB (b))
  | @ pC (nab))

new_ten2_Int_dbl =
  \ (ann : Allocation)-> proc ()
  new/ann [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_fuse_ten2_Int_dbl =
  \ (depth : Int)-> proc ()
  new/fuse depth [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_fuse0_ten2_Int_dbl =
  proc ()
  new/alloc [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_fuse1_ten2_Int_dbl =
  proc ()
  new/fuse 1 [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_fuse2_ten2_Int_dbl =
  proc ()
  new/fuse 2 [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_fuse3_ten2_Int_dbl =
  proc ()
  new/fuse 3 [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_fused_ten2_Int_dbl =
  proc ()
  new/fused [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {na#pC, nb#pC}.
    let x#pC : Int <- na#pC.
    nb#pC <- (x#pC + x#pC))

new_ten2_Int_fwd =
  proc ()
  new/fuse 2 [ab : [!Int, ?Int],nab : {?Int, !Int}].
  ( split ab [a, b].
    ( a <- 42
    | let b#pB : Int <- b )
  | split nab {nab#0#pC : ?Int, nab#1#pC : !Int}.
    let x#nab#0#pC : Int <- nab#0#pC.
    nab#1#pC <- x#nab#0#pC )

no_dead_lock_new_new =
  proc ()
  new [c : ?Int, d].
  new [e : ?Int, f].
  ( let x : Int <- c.
    f <- x
  | d <- 5
  | let y : Int <- e )

no_dead_lock_new_new_seq =
  proc ()
  new [: d : !Int, c :].
  new [: f : !Int, e :].
  d <- 5.
  let x : Int <- c.
  f <- x.
  let y : Int <- e

no_dead_lock_new_new_v2 =
  proc ()
  new [c : ?Int, d].
  new [e : ?Int, f].
  ( d <- 5
  | ( let x : Int <- c.
      f <- x
    | let y : Int <- e ))

non_dependent_function_type : Int -> Int =
  \ (x : Int)-> x + 1

assert
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> B a0 -> Type
  =
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> (b : B a0)-> Type
  : Type

assert
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> < ?B a0 >
  =
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> < ?(b : B a0)>
  : Type

some_type : Type =
  Int

some_value : Int =
  42

Oplus' =
  \ (SL : Session)-> \ (SR : Session)-> !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  }

leftOplus =
  \ (SL : Session)-> \ (SR : Session)-> \ (p : < SL >)-> proc (c)
  c : !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } <- `left.
  @ p (c)

rightOplus =
  \ (SL : Session)-> \ (SR : Session)-> \ (p : < SR >)-> proc (c)
  c : !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } <- `right.
  @ p (c)

oplus' =
  \ (SL : Session)-> \ (SR : Session)-> \ (b : LR)-> \ (p : < case b of {
    `left -> SL ,
    `right -> SR
  } >)-> proc (c)
  c : !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } <- b.
  @ p (c)

assert
  \ (SL : Session)-> \ (SR : Session)-> \ (p : < SL >)-> proc (c)
  c : !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } <- `left.
  @ p (c)
  =
  \ (SL : Session)-> \ (SR : Session)-> \ (p : < SL >)-> proc (c)
  c : !(b#22e2f863eed8f60e4b063335b421ec180fd2c0bc1e0df5b5d49df575ee8b2a05 : LR).case b#22e2f863eed8f60e4b063335b421ec180fd2c0bc1e0df5b5d49df575ee8b2a05 of {
    `left -> SL ,
    `right -> SR
  } <- `left.
  @ p (c)
  : (SL : Session)-> (SR : Session)-> (p : < SL >)-> < !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } >

assert
  \ (SL : Session)-> \ (SR : Session)-> \ (p : < SR >)-> proc (c)
  c : !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } <- `right.
  @ p (c)
  =
  \ (SL : Session)-> \ (SR : Session)-> \ (p : < SR >)-> proc (c)
  c : !(b#1b9d59315d374d6fdf83ea4fbe64aa4764aa563422ca2a800456c8869f9636eb : LR).case b#1b9d59315d374d6fdf83ea4fbe64aa4764aa563422ca2a800456c8869f9636eb of {
    `left -> SL ,
    `right -> SR
  } <- `right.
  @ p (c)
  : (SL : Session)-> (SR : Session)-> (p : < SR >)-> < !(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } >

par0 =
  proc (c : {})
  split c {}

par1 =
  proc (c : {!Int})
  split c {d}.
  d <- 42

par2 =
  proc (c : {!Int, ?Int})
  split c {d, e}.
  let x : Int <- e.
  d <- x

par2mix =
  proc (c : {!Int, ?Int})
  split c {d, e}.
  ( let x : Int <- e
  | d <- 42 )

par4_seq_send3 =
  proc (a : {[: !Int, !Int :], !Int, !Int, !Int})
  split a {b, e, f, g}.
  split b [: c, d :].
  e <- 1.
  c <- 2.
  f <- 3.
  d <- 4.
  g <- 5

parallel_assoc_2tensor2_left =
  proc (cde : [[!Int, !Int],!Int])
  split cde [cd, e].
  split cd [c, d].
  ( c <- 1
  | d <- 2
  | e <- 3 )

parallel_assoc_2tensor2_right =
  proc (cde : [[!Int, !Int],!Int])
  split cde [cd, e].
  ( split cd [c, d].
    ( c <- 1
    | d <- 2 )
  | e <- 3 )

parallel_assoc_flat =
  proc (c : !Int, d : !Int, e : !Int)
  ( c <- 1
  | d <- 2
  | e <- 3 )

parallel_assoc_left =
  proc (c : !Int, d : !Int, e : !Int)
  ( ( c <- 1
    | d <- 2 )
  | e <- 3 )

parallel_assoc_right =
  proc (c : !Int, d : !Int, e : !Int)
  ( c <- 1
  | ( d <- 2
    | e <- 3 ))

parallel_assoc_tensor3_flat =
  proc (cde : [!Int, !Int, !Int])
  split cde [c, d, e].
  ( c <- 1
  | d <- 2
  | e <- 3 )

parallel_assoc_tensor3_left =
  proc (cde : [!Int, !Int, !Int])
  split cde [c, d, e].
  ( c <- 1
  | ( d <- 2
    | e <- 3 ))

parallel_assoc_tensor3_right =
  proc (cde : [!Int, !Int, !Int])
  split cde [c, d, e].
  ( ( c <- 1
    | d <- 2 )
  | e <- 3 )

parallel_tensor4_flat =
  proc (cd : [!Int, !Int],ef : [!Int, !Int])
  split cd [c, d].
  split ef [e, f].
  ( c <- 1
  | e <- 2
  | d <- 3
  | f <- 4 )

parallel_tensor4_v0 =
  proc (cd : [!Int, !Int],ef : [!Int, !Int])
  split cd [c, d].
  split ef [e, f].
  ( ( c <- 1
    | e <- 2 )
  | ( d <- 3
    | f <- 4 ))

par_comm =
  \ (A : Session)-> \ (B : Session)-> proc (c : {[~ A, ~ B],{B, A}})
  split c {i, o}.
  split i [na, nb].
  split o {b, a}.
  ( fwd A (a, na)
  | fwd B (b, nb))

par_loli_ten_send =
  \ (S : Type)-> \ (T : Type)-> proc (c : {[?S, ?T],[!S, !T]})
  split c {i, o}.
  split i [rs, rt].
  split o [ss, st].
  ( let vs : S <- rs
  | let vt : T <- rt ).
  ( ss <- vs
  | st <- vt )

par_loli_ten_send_v2 =
  \ (S : Type)-> \ (T : Type)-> proc (c : {[?S, ?T],[!S, !T]})
  split c {i, o}.
  split i [rs, rt].
  ( let vs : S <- rs
  | let vt : T <- rt ).
  split o [ss, st].
  ( ss <- vs
  | st <- vt )

par_pat =
  proc (d : !Int, e : ?Int)
  let x#f#1 : Int <- e.
  d <- x#f#1

par_seq_back =
  proc (a : {[: !Int, !Int :], !Int})
  split a {b, e}.
  split b [: c, d :].
  c <- 2.
  d <- 3.
  e <- 1

par_seq_front =
  proc (a : {[: !Int, !Int :], !Int})
  split a {b, e}.
  split b [: c, d :].
  e <- 1.
  c <- 2.
  d <- 3

seqi =
  \ (S0 : Session)-> \ (S1 : Session)-> [: ~ S0, S1 :]

par_seqi_ten_send =
  \ (A : Type)-> \ (B : Type)-> proc (c : [: [?A, ?B],[!A, !B]:])
  split c [: i, o :].
  split i [rs, rt].
  split o [ss, st].
  ( let vs : A <- rs
  | let vt : B <- rt ).
  ( ss <- vs
  | st <- vt )

par_seq_middle =
  proc (a : {[: !Int, !Int :], !Int})
  split a {b, e}.
  split b [: c, d :].
  c <- 2.
  e <- 1.
  d <- 3

par_seq_send3 =
  proc (a : {[: !Int, !Int :], !Int.!Int.!Int})
  split a {b, e}.
  split b [: c, d :].
  e <- 1.
  c <- 2.
  e <- 3.
  d <- 4.
  e <- 5

par_ten1_ten1 =
  proc (c : {[?Int],[!Int]})
  split c {e, d}.
  split d [l].
  split e [h].
  let x : Int <- h.
  l <- x

par_ten_ten_v0 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  split c {e, d}.
  split d [k, l].
  split e [h, g].
  ( ( let x : Int <- h
    | ( k <- 1
      | let y : Int <- l ))
  | g <- 2 )

par_ten_ten_v1 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  split c {e, d}.
  split d [k, l].
  split e [h, g].
  ( let x : Int <- h
  | k <- 1
  | let y : Int <- l
  | g <- 2 )

par_ten_ten_v2 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  split c {e, d}.
  split d [k, l].
  split e [h, g].
  ( ( k <- 1
    | ( let x : Int <- h
      | let y : Int <- l ))
  | g <- 2 )

pattern_example_expanded =
  proc (abcde : [!Int, [: !Int, !Int :], {[!Int, !Int],{?Int, ?Int}}])
  split abcde [a, bc, de].
  split bc [: b, c :].
  split de {d, e}.
  ( a <- 1
  | b <- 2.
    c <- 3
  | split d [d#0 : !Int, d#1 : !Int].
    split e {e#0 : ?Int, e#1 : ?Int}.
    ( let x#e#0 : Int <- e#0.
      d#0 <- x#e#0
    | let x#e#1 : Int <- e#1.
      d#1 <- x#e#1 ))

plug_compose =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (p : < A, B >)-> \ (q : < ~ B, C >)-> proc (a : A, c : C)
  new [b : B, b' : ~ B].
  ( @ p {a, b}
  | @ q {b', c})

flat_par' =
  \ (A : Session)-> \ (B : Session)-> \ (p : < {A, B}>)-> proc (a : A, b : B)
  new [ab : {A, B},nanb].
  ( @ p (ab)
  | split nanb [na, nb].
    ( fwd A (a, na)
    | fwd B (b, nb)))

bump_par' =
  \ (A : Session)-> \ (B : Session)-> \ (p : < A, B >)-> proc (ab : {A, B})
  split ab {a, b}.
  @ p {a, b}

plug_compose' =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (p : < A, B >)-> \ (q : < ~ B, C >)-> proc (a : A, c : C)
  new [b : B, b' : ~ B].
  ( @ p {a, b}
  | @ q {b', c})

plug_compose_par_par : (A : Session)-> (B : Session)-> (C : Session)-> (p : < {A, B}>)-> (q : < {~ B, C}>)-> < {A, C}> =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (p : < {A, B}>)-> \ (q : < {~ B, C}>)-> proc (ab : {A, C})
  split ab {a, b}.
  new [b#p : B, b'#p : ~ B].
  ( new [ab#p#p : {A, B},nanb#p#p].
    ( @ p (ab#p#p)
    | split nanb#p#p [na#p#p, nb#p#p].
      ( fwd A (a, na#p#p)
      | fwd B (b#p, nb#p#p)))
  | new [ab#q#p : {~ C, C},nanb#q#p].
    ( @ q (ab#q#p)
    | split nanb#q#p [na#q#p, nb#q#p].
      ( fwd (~ C)(b'#p, na#q#p)
      | fwd C (b, nb#q#p))))

plug_send_recv =
  \ (p : < !Int, ?Int >)-> proc (c : !Int, d : ?Int)
  @ p {c, d}

_ =
  1

_ =
  2

_ =
  "Hello!"

test_receiver =
  \ (A : Type)-> \ (S : A -> Session)-> \ (p : (x : A)-> < S x >)-> proc (c)
  let x : A <- c.
  @ (p x)(c)

assert
  16
  =
  16


assert
  32
  =
  32


assert
  64
  =
  64


assert
  128
  =
  128


assert
  256
  =
  256


assert
  512
  =
  512


assert
  `false
  =
  `false


assert
  `true
  =
  `true


assert
  3.14
  =
  3.14


assert
  3.14
  =
  3.14


assert
  3.14
  =
  3.14


assert
  3.14
  =
  3.14


assert
  0.9977000638225533
  =
  0.9977000638225533


assert
  3.0000000000000004
  =
  3.0000000000000004


assert
  `true
  =
  `true


assert
  `false
  =
  `false


assert
  42.0
  =
  42.0


assert
  `false
  =
  `false


assert
  "42"
  =
  "42"


assert
  `false
  =
  `false


assert
  "3.14"
  =
  "3.14"


assert
  `false
  =
  `false


assert
  "'a'"
  =
  "'a'"


assert
  `true
  =
  `true


assert
  "\"Hello \\\"World\\\"!\""
  =
  "\"Hello \\\"World\\\"!\""


assert
  `false
  =
  `false


assert
  "Hello World!"
  =
  "Hello World!"


assert
  "Hello Let!"
  =
  "Hello Let!"


replicate =
  \ (A : Type)-> \ (n : Int)-> \ (x : A)-> proc (os : [!A ^ n])
  split os [o ^ n].
  parallel ^ n
    o <- x

replicate_par =
  proc (c : {!Int ^ 10})
  split c {d ^ 10}.
  sequence ^ 10 with i
    d <- i

replicate_proc =
  \ (A : Type)-> \ (n : Int)-> proc (c : {?A, [!A ^ n]})
  split c {i, os}.
  let x : A <- i.
  split os [o ^ n].
  parallel ^ n
    o <- x

replicate_proc_Int_10 =
  proc (c : {?Int, [!Int ^ 10]})
  split c {i, os}.
  let x : Int <- i.
  split os [o ^ 10].
  parallel ^ 10
    o <- x

tabulate_ten =
  \ (A : Type)-> \ (f : (i : Int)-> A)-> \ (n : Int)-> proc (c : [!A ^ n])
  split c [c_ ^ n].
  parallel ^ n with i
    c_ <- (f i)

replicate_ten_10 =
  proc (c : [!Int ^ 10])
  split c [c_ ^ 10].
  parallel ^ 10 with i
    c_ <- i

rotate_seq =
  \ (A : Type)-> \ (n : Int)-> proc (i : [: ?A ^ (1 + n):], o : [: !A ^ (n + 1):])
  split i [: iL, iH ^ n :].
  split o [: oL ^ n, oH :].
  let xL : A <- iL.
  (sequence ^ n
    (let x#iH : A <- iH.
    oL <- x#iH)).
  oH <- xL

test_sender =
  \ (A : Type)-> \ (S : A -> Session)-> \ (t : A)-> \ (p : < S t >)-> proc (c)
  c : !(x : A).S x <- t.
  @ p (c)

seq0_explicit =
  proc (c : [: :])
  split c [: :]

seq0 =
  proc (c : [: :])
  ( )

seq3 =
  proc (c : [: !Int, !Int, !Int :])
  split c [: c0, c1, c2 :].
  c0 <- 0.
  c1 <- 1.
  c2 <- 2

seq3_seq2 =
  proc (c : [: !Int, !Int, !Int :], d : [: !Int, !Int :])
  split c [: c0, c1, c2 :].
  split d [: d0, d1 :].
  c0 <- 0.
  c1 <- 1.
  d0 <- 0.
  c2 <- 2.
  d1 <- 1

seq_assoc_core =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> proc (i : [: [: ~ A, ~ B :], ~ C :], o : [: A, [: B, C :] :])
  split i [: nab, nc :].
  split nab [: na, nb :].
  split o [: a, bc :].
  split bc [: b, c :].
  fwd A (a, na).
  fwd B (b, nb).
  fwd C (c, nc)

seq_par_back =
  proc (a : [: {!Int, !Int},!Int :])
  split a [: b, e :].
  split b {c, d}.
  c <- 2.
  d <- 3.
  e <- 1

seq_par_back_v2 =
  proc (a : [: {!Int, !Int},!Int :])
  split a [: b, e :].
  split b {c, d}.
  d <- 3.
  c <- 2.
  e <- 1

seq_pat =
  proc (c : [: ?Int, !Int :])
  split c [: d, e :].
  let x#g : Int <- d.
  e <- x#g

seq_seq =
  proc (a : [: [: !Int, !Int :], !Int :])
  split a [: b, e :].
  split b [: c, d :].
  c <- 1.
  d <- 2.
  e <- 3

seq_seq_send2 =
  proc (a : [: [: !Int.!Int, !Int.!Int :], !Int.!Int :])
  split a [: b, e :].
  split b [: c, d :].
  c <- 1.
  c <- 2.
  d <- 3.
  d <- 4.
  e <- 5.
  e <- 6

seq_ten =
  proc (a : [: [!Int, !Int],!Int :])
  split a [: b, e :].
  split b [c, d].
  ( c <- 2.
    e <- 1
  | d <- 3 )

singleRecv =
  proc (c : ?Int)
  let x : Int <- c

singleSend =
  proc (c : !Int)
  c <- 42

sorter =
  \ (n : Int)-> proc (c : {?Vec Int n, !Vec Int n})
  split c {ci, co}.
  let v : Vec Int n <- ci.
  co <- (sort n v)

split_fwd1_rcv =
  proc (c : {?Int})
  split c {d}.
  let x#d : Int <- d

split_nested_seq : (A : Session)-> (B : Session)-> (C : Session)-> (D : Session)-> < {[: ~ A, ~ B, ~ C, ~ D :], [: [: A, B :], [: C, D :] :]}> =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (D : Session)-> proc (c : {[: ~ A, ~ B, ~ C, ~ D :], [: [: A, B :], [: C, D :] :]})
  split c {i, o}.
  split i [: na, nb, nc, nd :].
  split o [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  fwd A (a, na).
  fwd B (b, nb).
  fwd C (c, nc).
  fwd D (d, nd)

sqr_dbl =
  proc (i : ?Int, o : !Int)
  let x : Int <- i.
  new/alloc (c :* Int).
  c <- (x * x).
  let y : Int <- c.
  o <- (y + y)

sqrs_body_session =
  !Int.?Int.!Int.?Int.!Int.?Int

sqrs_body =
  \ (x : Int)-> proc (c : !Int.?Int.!Int.?Int.!Int.?Int, o : !Int)
  c <- (x * x).
  let x2 : Int <- c.
  c <- (x2 * x2).
  let x4 : Int <- c.
  c <- (x4 * x4).
  let x8 : Int <- c.
  o <- (x8 * x8)

sqrs_main =
  proc (i : ?Int, o : !Int)
  let x : Int <- i.
  new/alloc (c :* Int).
  c <- (x * x).
  let x2 : Int <- c.
  c <- (x2 * x2).
  let x4 : Int <- c.
  c <- (x4 * x4).
  let x8 : Int <- c.
  o <- (x8 * x8)

sqrs =
  proc (i : ?Int, o : !Int)
  let x : Int <- i.
  new/alloc (c :* Int).
  c <- (x * x).
  let x2 : Int <- c.
  c <- (x2 * x2).
  let x4 : Int <- c.
  c <- (x4 * x4).
  let x8 : Int <- c.
  o <- (x8 * x8)

sum_int =
  proc (a : {?Int ^ 10},r : !Int)
  new/alloc (acc :* Int).
  acc <- 0.
  split acc [: acci ^ 10, accn :].
  split a {ai ^ 10}.
  (sequence ^ 10 with i
    (let x : Int <- ai.
    let y : Int <- acci.
    acci <- (x + y)) ).
  let x#accn : Int <- accn.
  r <- x#accn

switch : (A : Session)-> (B : Session)-> (C : Session)-> < {{~ A, [~ B, ~ C]}, {[A, B],C}} > =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> proc (c : {{~ A, [~ B, ~ C]}, {[A, B],C}})
  split c {i, o}.
  split i {na, nbc}.
  split nbc [nb, nc].
  split o {ab, c}.
  split ab [a, b].
  ( fwd A (a, na)
  | fwd B (b, nb)
  | fwd C (c, nc))

tabulate_seq =
  \ (A : Type)-> \ (f : (i : Int)-> A)-> \ (n : Int)-> proc (a : [: !A ^ n :])
  split a [: a_i ^ n :].
  sequence ^ n with i
    a_i <- (f i)

tabulate_seq_Double_40 =
  proc (a : [: !Double ^ 41 :])
  split a [: a_i ^ 41 :].
  sequence ^ 41 with i
    a_i <- (1.0 -D 5.0e-2 *D Int2Double i)

ten_loli_par =
  \ (A : Session)-> \ (B : Session)-> proc (c : {{~ A, ~ B},{A, B}})
  split c {i, o}.
  split i {na, nb}.
  split o {a, b}.
  ( fwd A (a, na)
  | fwd B (b, nb))

ten_loli_par_sInt_sDouble =
  proc (c : {{?Int, ?Double},{!Int, !Double}})
  split c {i, o}.
  split i {na, nb}.
  split o {a, b}.
  ( let x#na : Int <- na.
    a <- x#na
  | let x#nb : Double <- nb.
    b <- x#nb )

ten_loli_par_sequential =
  \ (A : Session)-> \ (B : Session)-> proc (c : {{~ A, ~ B},{A, B}})
  split c {i, o}.
  split i {na, nb}.
  split o {a, b}.
  fwd A (a, na).
  fwd B (b, nb)

ten_par_par_split =
  proc (c : [{}, {}])
  split c [d, e].
  ( split d {}
  | split e {} )

tensor0 =
  proc (c : [])
  split c []

tensor1 =
  proc (c : [!Int])
  split c [d].
  d <- 42

tensor2 =
  proc (c : [!Int, ?Int])
  split c [d, e].
  ( let x : Int <- e
  | d <- 42 )

tensor2_tensor0_tensor0_parallel =
  proc (cd : [[], []])
  split cd [c, d].
  ( split c []
  | split d [] )

tensor2_tensor0_tensor0_sequence =
  proc (cd : [[], []])
  split cd [c, d].
  split c [].
  split d []

tensor2_using_dual =
  proc (c : [!Int, ?Int])
  split c [d, e].
  ( let x : Int <- e
  | d <- 42 )

test2 =
  proc ()
  new [c : {?Int.!Int.?Int, !Int.?Int.!Int},d].
  ( split c {c0, c1}.
    let x0 : Int <- c0.
    c1 <- (x0 + 1).
    let x1 : Int <- c1.
    c0 <- (x1 + x0 + 2).
    let x2 : Int <- c0.
    c1 <- (x2 + x1 + x0 + 3)
  | split d [d0, d1].
    ( d0 <- 1.
      let y0 : Int <- d0.
      d0 <- (y0 + 4)
    | let z0 : Int <- d1.
      d1 <- (z0 + 5).
      let z1 : Int <- d1 ))

test3 =
  proc ()
  new [c : ?Int.[!Int, !Int],d].
  ( let x0 : Int <- c.
    split c [c0, c1].
    ( c0 <- x0
    | c1 <- x0 )
  | d <- 1.
    split d {d0, d1}.
    ( let y0 : Int <- d0
    | let z0 : Int <- d1 ))

test4_inferred =
  proc (r)
  new [c, d].
  ( let x0 : Int <- c.
    let x1 : Int <- c.
    let x2 : Int <- c.
    r <- (x0 + x1 + x2)
  | d <- 1.
    d <- 2.
    d <- 3 )

test4 =
  proc (r : !Int)
  new [c : ?Int.?Int.?Int, d].
  ( let x0 : Int <- c.
    let x1 : Int <- c.
    let x2 : Int <- c.
    r <- (x0 + x1 + x2)
  | d <- 1.
    d <- 2.
    d <- 3 )

test_pat_term =
  proc (abcde : [!Int, [: !Int, !Int :], {[!Int, !Int],{?Int, ?Int}}])
  split abcde [a, bc, de].
  split bc [: b, c :].
  split de {d, e}.
  ( a <- 1
  | b <- 2.
    c <- 3
  | split d [d#0 : !Int, d#1 : !Int].
    split e {e#0 : ?Int, e#1 : ?Int}.
    ( let x#e#0 : Int <- e#0.
      d#0 <- x#e#0
    | let x#e#1 : Int <- e#1.
      d#1 <- x#e#1 ))

test_pat =
  proc (bcaed : [[: !Int, !Int :], !Int, {{?Int, ?Int},[!Int, !Int]}])
  split bcaed [bc, a, ed].
  split bc [: b, c :].
  split ed {e, d}.
  @ (proc (abcde : [!Int, [: !Int, !Int :], {[!Int, !Int],{?Int, ?Int}}])
  split abcde [a, bc, de].
  split bc [: b, c :].
  split de {d, e}.
  ( a <- 1
  | b <- 2.
    c <- 3
  | split d [d#0 : !Int, d#1 : !Int].
    split e {e#0 : ?Int, e#1 : ?Int}.
    ( let x#e#0 : Int <- e#0.
      d#0 <- x#e#0
    | let x#e#1 : Int <- e#1.
      d#1 <- x#e#1 ))) [a, [: b, c :], {d, e}]

type_annotation =
  42

assert
  `true
  =
  `true
  : Bool

ZeroCh : Type =
  (A : Type)-> A

One : Type =
  (A : Type)-> (x : A)-> A

zeroOne : (A : Type)-> (x : A)-> A =
  \ (A : Type)-> \ (x : A)-> x

Two : Type =
  (A : Type)-> (x : A)-> (y : A)-> A

zeroTwo : (A : Type)-> (x : A)-> (y : A)-> A =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x

oneTwo : (A : Type)-> (x : A)-> (y : A)-> A =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y

notTwo : (b : (A : Type)-> (x : A)-> (y : A)-> A)-> (A : Type)-> (x : A)-> (y : A)-> A =
  \ (b : (A : Type)-> (x : A)-> (y : A)-> A)-> \ (A : Type)-> \ (x : A)-> \ (y : A)-> b A y x

notZero : (A : Type)-> (x : A)-> (y : A)-> A =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y

notZero' : (A : Type)-> (x : A)-> (y : A)-> A =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x

notZero'' : (A : Type)-> (x : A)-> (y : A)-> A =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y

assert
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x
  : (A : Type)-> (x : A)-> (y : A)-> A

andTwo : (b0 : (A : Type)-> (x : A)-> (y : A)-> A)-> (b1 : (A : Type)-> (x : A)-> (y : A)-> A)-> (A : Type)-> (x : A)-> (y : A)-> A =
  \ (b0 : (A : Type)-> (x : A)-> (y : A)-> A)-> \ (b1 : (A : Type)-> (x : A)-> (y : A)-> A)-> b0 ((A : Type)-> (x : A)-> (y : A)-> A)(\ (A : Type)-> \ (x : A)-> \ (y : A)-> x)b1

assert
  \ (A#x#b0 : Type)-> \ (x#x#b0 : A#x#b0)-> \ (y#x#b0 : A#x#b0)-> x#x#b0
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A#x#b0 : Type)-> \ (x#x#b0 : A#x#b0)-> \ (y#x#b0 : A#x#b0)-> x#x#b0
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A#b1 : Type)-> \ (x#b1 : A#b1)-> \ (y#b1 : A#b1)-> x#b1
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A#b1 : Type)-> \ (x#b1 : A#b1)-> \ (y#b1 : A#b1)-> y#b1
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y
  : (A : Type)-> (x : A)-> (y : A)-> A

orTwo : (b0 : (A : Type)-> (x : A)-> (y : A)-> A)-> (b1 : (A : Type)-> (x : A)-> (y : A)-> A)-> (A : Type)-> (x : A)-> (y : A)-> A =
  \ (b0 : (A : Type)-> (x : A)-> (y : A)-> A)-> \ (b1 : (A : Type)-> (x : A)-> (y : A)-> A)-> b0 ((A : Type)-> (x : A)-> (y : A)-> A)b1 (\ (A : Type)-> \ (x : A)-> \ (y : A)-> y)

assert
  \ (A#b1 : Type)-> \ (x#b1 : A#b1)-> \ (y#b1 : A#b1)-> x#b1
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A#b1 : Type)-> \ (x#b1 : A#b1)-> \ (y#b1 : A#b1)-> y#b1
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A#y#b0 : Type)-> \ (x#y#b0 : A#y#b0)-> \ (y#y#b0 : A#y#b0)-> y#y#b0
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y
  : (A : Type)-> (x : A)-> (y : A)-> A

assert
  \ (A#y#b0 : Type)-> \ (x#y#b0 : A#y#b0)-> \ (y#y#b0 : A#y#b0)-> y#y#b0
  =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y
  : (A : Type)-> (x : A)-> (y : A)-> A

Nat : Type =
  (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

zeroNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (n : A)-> A)-> z

sucNat : (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (n A z s)

oneNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s z

twoNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s z)

threeNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s (s z))

fourNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s (s (s z)))

fiveNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s (s (s (s z))))

sixNat : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s (s (s (s (s z)))))

addNat : (m : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (m : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> \ (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> m ((A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)n (\ (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (n A z s))

assert
  \ (A#n : Type)-> \ (z#n : A#n)-> \ (s#n : (m#n : A#n)-> A#n)-> s#n z#n
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s z
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#s#m : Type)-> \ (z#s#m : A#s#m)-> \ (s#s#m : (m#c94ec791bb72f06cbe4734e579cde852eaac34d4bdc2b35ab5ebc9f1546348ec#s#m : A#s#m)-> A#s#m)-> s#s#m z#s#m
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s z
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#s#m : Type)-> \ (z#s#m : A#s#m)-> \ (s#s#m : (m#5d0fc7b2cedae37cd88c41e9524f5879c579fe740122e5405d44ffc778cc525d#s#m : A#s#m)-> A#s#m)-> s#s#m (s#s#m (s#s#m (s#s#m (s#s#m z#s#m))))
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s (s (s (s z))))
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

mulNat : (m : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A =
  \ (m : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> \ (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> m ((A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)(\ (A : Type)-> \ (z : A)-> \ (s : (n : A)-> A)-> z)(\ (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> n ((A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)n (\ (n : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> \ (A : Type)-> \ (z : A)-> \ (s : (m#d7e330a0314d1cec9f612e669477a8f9bd582844bee41fd19866cad236183168 : A)-> A)-> s (n A z s)))

assert
  \ (A#z#m : Type)-> \ (z#z#m : A#z#m)-> \ (s#z#m : (n#z#m : A#z#m)-> A#z#m)-> z#z#m
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (n : A)-> A)-> z
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#z#m#n#s#m#z#z#m#n#s#m : Type)-> \ (z#z#m#n#s#m#z#z#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m)-> \ (s#z#m#n#s#m#z#z#m#n#s#m : (n#z#m#n#s#m#z#z#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m)-> A#z#m#n#s#m#z#z#m#n#s#m)-> z#z#m#n#s#m#z#z#m#n#s#m
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (n : A)-> A)-> z
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#z#m#n#s#m#z#z#m#n#s#m : Type)-> \ (z#z#m#n#s#m#z#z#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m)-> \ (s#z#m#n#s#m#z#z#m#n#s#m : (n#z#m#n#s#m#z#z#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m)-> A#z#m#n#s#m#z#z#m#n#s#m)-> z#z#m#n#s#m#z#z#m#n#s#m
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s z
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#z#m#n#s#m#z#z#m#n#s#m : Type)-> \ (z#z#m#n#s#m#z#z#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m)-> \ (s#z#m#n#s#m#z#z#m#n#s#m : (n#z#m#n#s#m#z#z#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m)-> A#z#m#n#s#m#z#z#m#n#s#m)-> z#z#m#n#s#m#z#z#m#n#s#m
  =
  \ (A#s#m : Type)-> \ (z#s#m : A#s#m)-> \ (s#s#m : (m#c94ec791bb72f06cbe4734e579cde852eaac34d4bdc2b35ab5ebc9f1546348ec#s#m : A#s#m)-> A#s#m)-> s#s#m z#s#m
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : Type)-> \ (z#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m)-> \ (s#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : (n#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m)-> A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m)-> z#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m
  =
  \ (A#s#m : Type)-> \ (z#s#m : A#s#m)-> \ (s#s#m : (m#6c9189abda3c8f3421235b23bb1bcd7a8b65cf7c218b9b66706b02aa05dc5819#s#m : A#s#m)-> A#s#m)-> s#s#m (s#s#m (s#s#m (s#s#m (s#s#m (s#s#m z#s#m)))))
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

assert
  \ (A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : Type)-> \ (z#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m)-> \ (s#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : (n#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m : A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m)-> A#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m)-> z#z#m#n#s#m#z#z#m#n#s#m#n#s#m#z#z#m#n#s#m#z#z#m#n#s#m#n#s#m
  =
  \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (s (s (s (s (s z)))))
  : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

Bin : Type =
  (A : Type)-> (leaf : A)-> (fork : (left : A)-> (right : A)-> A)-> A

Nats : Type =
  (A : Type)-> (nil : A)-> (cons : (head : (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A)-> (tail : A)-> A)-> A

List : (X : Type)-> Type =
  \ (X : Type)-> (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A

nilList : (X : Type)-> (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A =
  \ (X : Type)-> \ (A : Type)-> \ (nil : A)-> \ (cons : (head : X)-> (tail : A)-> A)-> nil

consList : (X : Type)-> (head : X)-> (tail : (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A)-> (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A =
  \ (X : Type)-> \ (head : X)-> \ (tail : (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A)-> \ (A : Type)-> \ (nil : A)-> \ (cons : (head' : X)-> (tail' : A)-> A)-> cons head (tail A nil cons)

mapList : (X : Type)-> (Y : Type)-> (f : (x : X)-> Y)-> (xs : (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A)-> (A : Type)-> (nil : A)-> (cons : (head : Y)-> (tail : A)-> A)-> A =
  \ (X : Type)-> \ (Y : Type)-> \ (f : (x : X)-> Y)-> \ (xs : (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A)-> \ (A : Type)-> \ (nil : A)-> \ (cons : (head' : Y)-> (tail' : A)-> A)-> xs A nil (\ (head : X)-> \ (tail : A)-> cons (f head)tail)

Id : (A : Type)-> (x : A)-> (y : A)-> Type

refl : (A : Type)-> (x : A)-> Id A x x

J : (A : Type)-> (x : A)-> (P : (y : A)-> (p : Id A x y)-> Type)-> (Px : P x (refl A x)) -> (y : A)-> (p : Id A x y)-> P y p

J-refl : (A : Type)-> (x : A)-> (P : (y : A)-> (p : Id A x y)-> Type)-> (Px : P x (refl A x)) -> Id (P x (refl A x)) (J A x P Px x (refl A x)) Px

tr : (A : Type)-> (x : A)-> (P : (y : A)-> Type)-> (Px : P x)-> (y : A)-> (p : Id A x y)-> P y =
  \ (A : Type)-> \ (x : A)-> \ (P : (y : A)-> Type)-> \ (Px : P x)-> \ (y : A)-> \ (p : Id A x y)-> J A x (\ (z : A)-> \ (q : Id A x z)-> P z)Px y p

tr-refl : (A : Type)-> (x : A)-> (P : (y : A)-> Type)-> (Px : P x)-> Id (P x)(J A x (\ (z : A)-> \ (q : Id A x z)-> P z)Px x (refl A x)) Px =
  \ (A : Type)-> \ (x : A)-> \ (P : (y : A)-> Type)-> \ (Px : P x)-> J-refl A x (\ (z : A)-> \ (q : Id A x z)-> P z)Px

coe : (A : Type)-> (B : Type)-> (p : Id Type A B)-> (x : A)-> B =
  \ (A : Type)-> \ (B : Type)-> \ (p : Id Type A B)-> \ (x : A)-> J Type A (\ (z : Type)-> \ (q : Id Type A z)-> z)x B p

coe-refl : (A : Type)-> (x : A)-> Id A (J Type A (\ (z : Type)-> \ (q : Id Type A z)-> z)x A (refl Type A)) x =
  \ (A : Type)-> \ (x : A)-> J-refl Type A (\ (z : Type)-> \ (q : Id Type A z)-> z)x

sym : (A : Type)-> (x : A)-> (y : A)-> (p : Id A x y)-> Id A y x =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> \ (p : Id A x y)-> J A x (\ (z : A)-> \ (q : Id A x z)-> Id A z x)(refl A x)y p

trans : (A : Type)-> (x : A)-> (y : A)-> (z : A)-> (p : Id A x y)-> (q : Id A y z)-> Id A x z =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> \ (z : A)-> \ (p : Id A x y)-> \ (q : Id A y z)-> J A z (\ (z : A)-> \ (q : Id A z z)-> Id A x z)q z q

uncurry =
  \ (S : Session)-> \ (T : Session)-> \ (U : Session)-> proc (c : {[S, [T, ~ U]], {{~ S, ~ T},U}})
  split c {f, xyo}.
  split xyo {xy, o}.
  split xy {x, y}.
  split f [fx, fyo].
  split fyo [fy, fo].
  ( fwd S (fx, x)
  | fwd T (fy, y)
  | fwd U (o, fo))

test_With =
  \ (SL : Session)-> \ (SR : Session)-> ?(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  }

test_with =
  \ (SL : Session)-> \ (SR : Session)-> \ (pL : < SL >)-> \ (pR : < SR >)-> proc (c : ?(b : LR).case b of {
    `left -> SL ,
    `right -> SR
  } )
  let x : LR <- c.
  @ (case x of {
    `left -> pL ,
    `right -> pR
  } ) (c)

zap =
  \ (S : Session)-> \ (T : Session)-> \ (n : Int)-> proc (c : {{[S, ~ T]^ n},{{~ S ^ n},[T ^ n]}})
  split c {fs, xos}.
  split xos {xs, os}.
  split fs {f ^ n}.
  split xs {x ^ n}.
  split os [o ^ n].
  parallel ^ n
    (split f [fi, fo].
    ( fwd S (fi, x)
    | fwd T (o, fo)))

zap_ten_fwd =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  split cf {cfi ^ 10}.
  split cn {cni ^ 10}.
  split co [coi ^ 10].
  parallel ^ 10
    (split cfi {cfii, cfio}.
    ( let x#cni : Int <- cni.
      cfii <- x#cni
    | let x#cfio : Int <- cfio.
      coi <- x#cfio ))

zap_ten_par =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  split cf {cfi ^ 10}.
  split cn {cni ^ 10}.
  split co [coi ^ 10].
  parallel ^ 10
    (split cfi {cfii, cfio}.
    ( let x : Int <- cni.
      cfii <- x
    | let y : Int <- cfio.
      coi <- y ))

zap_ten_seq =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  split cf {cfi ^ 10}.
  split cn {cni ^ 10}.
  split co [coi ^ 10].
  sequence ^ 10
    (split cfi {cfii, cfio}.
    let x : Int <- cni.
    cfii <- x.
    let y : Int <- cfio.
    coi <- y)

zip_add =
  proc (xs : {?Int ^ 10},ys : {?Int ^ 10},zs : [!Int ^ 10])
  split xs {x ^ 10}.
  split ys {y ^ 10}.
  split zs [z ^ 10].
  parallel ^ 10
    (let a : Int <- x.
    let b : Int <- y.
    z <- (a + b))
