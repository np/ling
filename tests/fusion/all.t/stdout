
{- Sequential Fused program -}

assert
  'a'
  =
  'a'
  : Char

ap =
  \ (S : Session)-> \ (T : Session)-> proc (c : {[S, ~ T],{~ S, T}})
  split c {f, xo}.
  split xo {x, o}.
  split f [fi, fo].
  ( fwd S (fi, x)
  | fwd T (o, fo))

ap_SInt_SBool =
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = !Int in
  let T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7 : Session = !Bool in
  proc (c : {[S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7],{~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7}})
  split c {f, xo}.
  split xo {x, o}.
  split f [fi, fo].
  fwd S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a (fi, x).
  fwd T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7 (o, fo)

assert
  `false
  =
  `false
  : Bool

assert
  \ (x : Bool)-> x
  =
  \ (y : Bool)-> y
  : (b : Bool)-> Bool

assert
  not `true
  =
  `false
  : Bool

assert
  proc (r : ?Bool.!Bool)
  let x : Bool <- r.
  r <- x
  =
  proc (r : ?Bool.!Bool)
  let y : Bool <- r.
  r <- y
  : < ?Bool.!Bool >

assert
  proc (r : !Bool)
  r <- (not `true)
  =
  proc (r : !Bool)
  r <- `false
  : < !Bool >

another_not : (x : Bool)-> Bool =
  \ (x : Bool)-> case x of {
    `false -> `true ,
    `true -> `false
  }

pnot =
  proc (c : ?Bool.!Bool)
  let x : Bool <- c.
  c <- (case x of {
    `false -> `true ,
    `true -> `false
  } )

if : (b : Bool)-> (A : Type)-> (t : A)-> (e : A)-> A =
  \ (b : Bool)-> \ (A : Type)-> \ (t : A)-> \ (e : A)-> case b of {
    `false -> e ,
    `true -> t
  }

If : (b : Bool)-> (A : Type)-> (B : Type)-> (t : A)-> (e : B)-> case b of {
    `false -> B ,
    `true -> A
  } =
  \ (b : Bool)-> \ (A : Type)-> \ (B : Type)-> \ (t : A)-> \ (e : B)-> case b of {
    `false -> e ,
    `true -> t
  }

assert
  not `true
  =
  `false


assert
  not `false
  =
  `true


assert
  `false && `false
  =
  `false


assert
  `false && `true
  =
  `false


assert
  `true && `false
  =
  `false


assert
  `true && `true
  =
  `true


assert
  `false || `false
  =
  `false


assert
  `false || `true
  =
  `true


assert
  `true || `false
  =
  `true


assert
  `true || `true
  =
  `true


assert
  `false ==B `false
  =
  `true


assert
  `false ==B `true
  =
  `false


assert
  `true ==B `false
  =
  `false


assert
  `true ==B `true
  =
  `true


assert
  `false /=B `false
  =
  `false


assert
  `false /=B `true
  =
  `true


assert
  `true /=B `false
  =
  `true


assert
  `true /=B `true
  =
  `false


case_con : case `true of {
    `false -> Bool ,
    `true -> Int
  } =
  1

com_new =
  \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> \ (ann : Allocation)-> proc ()
  new/ann [c : S, d : ~ S].
  ( @ p (c)
  | @ q (d))

com_new_SInt =
  com_new (!Int)(proc (c' : !Int)
  c' <- 42)(proc (d : ?Int)
  let x : Int <- d)

com_new_SInt_alloc =
  proc ()
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc.
  let p#5554dd5f470e6ed0f2e5fbc1e4c23a5f4dd5b16757bbe563455768a667b6e00c : < S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c'#p : !Int)
  c'#p <- 42).
  let q#74dbc8252fe888ddf597a3487bdf98df293e4d0fe41379412212e047ab1859b3 : < ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (d#q : ?Int)
  let x#q : Int <- d#q).
  new/ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [c : S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, d : ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a].
  c <- 42.
  let x#q : Int <- d

com_new_SInt_fuse1 =
  proc ()
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let ann#cc40f3dcd14927decb69fc86af066439772650ab76dfb9a3483879be91560789 : Allocation = fuse1.
  let p#5554dd5f470e6ed0f2e5fbc1e4c23a5f4dd5b16757bbe563455768a667b6e00c : < S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c'#p : !Int)
  c'#p <- 42).
  let q#74dbc8252fe888ddf597a3487bdf98df293e4d0fe41379412212e047ab1859b3 : < ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (d#q : ?Int)
  let x#q : Int <- d#q).
  let x#q : Int = 42.
  new/alloc [c : [: :], d : [: :]]

com_new_SInt_RBool =
  com_new (!Int.?Bool)(proc (c' : !Int.?Bool)
  c' <- 42.
  let b : Bool <- c')(proc (d : ?Int.!Bool)
  let x : Int <- d.
  d <- `true)

com_new_SInt_RBool_alloc =
  proc ()
  let S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca : Session = (!Int.?Bool).
  let ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc.
  let p#c2265179388dfb6a9162794b4025c7d02b635b24684ce04c5bbf389df9502e5b : < S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (c'#p : !Int.?Bool)
  c'#p <- 42.
  let b#p : Bool <- c'#p).
  let q#a718104b7522487772e05b5dfcbfa8089848257aef94552ee25ba954ea121a4c : < ~ S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (d#q : ?Int.!Bool)
  let x#q : Int <- d#q.
  d#q <- `true).
  new/ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [c : S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca, d : ~ S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca].
  c <- 42.
  let x#q : Int <- d.
  d <- `true.
  let b#p : Bool <- c

com_new_SInt_RBool_fuse1 =
  proc ()
  let S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca : Session = (!Int.?Bool).
  let ann#cc40f3dcd14927decb69fc86af066439772650ab76dfb9a3483879be91560789 : Allocation = fuse1.
  let p#c2265179388dfb6a9162794b4025c7d02b635b24684ce04c5bbf389df9502e5b : < S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (c'#p : !Int.?Bool)
  c'#p <- 42.
  let b#p : Bool <- c'#p).
  let q#a718104b7522487772e05b5dfcbfa8089848257aef94552ee25ba954ea121a4c : < ~ S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (d#q : ?Int.!Bool)
  let x#q : Int <- d#q.
  d#q <- `true).
  let x#q : Int = 42.
  new/alloc [c : ?Bool, d : !Bool].
  d <- `true.
  let b#p : Bool <- c

com_new_SInt_RBool_fuse2 =
  proc ()
  let S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca : Session = (!Int.?Bool).
  let ann#5c17eb5b88064ce5775fe297433913ed0646e660ef86644367d803be0a911af8 : Allocation = fuse2.
  let p#c2265179388dfb6a9162794b4025c7d02b635b24684ce04c5bbf389df9502e5b : < S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (c'#p : !Int.?Bool)
  c'#p <- 42.
  let b#p : Bool <- c'#p).
  let q#a718104b7522487772e05b5dfcbfa8089848257aef94552ee25ba954ea121a4c : < ~ S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (d#q : ?Int.!Bool)
  let x#q : Int <- d#q.
  d#q <- `true).
  let x#q : Int = 42.
  let b#p : Bool = `true.
  new/alloc [d : [: :], c : [: :]]

com_new_SInt_RBool_fuse3 =
  proc ()
  let S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca : Session = (!Int.?Bool).
  let ann#1fd7702d77e161ac45815cbc270061bd3e9493e42deb56012e5eb2a5efd73837 : Allocation = fuse3.
  let p#c2265179388dfb6a9162794b4025c7d02b635b24684ce04c5bbf389df9502e5b : < S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (c'#p : !Int.?Bool)
  c'#p <- 42.
  let b#p : Bool <- c'#p).
  let q#a718104b7522487772e05b5dfcbfa8089848257aef94552ee25ba954ea121a4c : < ~ S#7622c0cec5e744e44bc95eccba8e3a333bcee97ead3cfae8052de7ee40b545ca > = (proc (d#q : ?Int.!Bool)
  let x#q : Int <- d#q.
  d#q <- `true).
  let x#q : Int = 42.
  let b#p : Bool = `true

com_new_mk_ten2 =
  let mk_tensor2 = \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  ( @ p0 (c0)
  | @ p1 (c1))in
  \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> \ (ann : Allocation)-> proc ()
  new/ann [c : S, d : ~ S].
  @ (mk_tensor2 S (~ S)p q)[c, d]

com_new_mk_ten2_SInt =
  com_new_mk_ten2 (!Int)(proc (c' : !Int)
  c' <- 42)(proc (d : ?Int)
  let x : Int <- d)

com_new_mk_ten2_SInt_alloc =
  proc ()
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc.
  let mk_tensor2 = (\ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  ( @ p0 (c0)
  | @ p1 (c1))).
  let p#5554dd5f470e6ed0f2e5fbc1e4c23a5f4dd5b16757bbe563455768a667b6e00c : < S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c'#p : !Int)
  c'#p <- 42).
  let q#74dbc8252fe888ddf597a3487bdf98df293e4d0fe41379412212e047ab1859b3 : < ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (d#q : ?Int)
  let x#q : Int <- d#q).
  let S1#1dbf20ff644fdad3e47918591ef9ed1ca79b13e3816d109e025eb585eef86af0 : Session = (~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a).
  new/ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [c : S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, d : ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a].
  c <- 42.
  let x#q : Int <- d

com_new_mk_ten2_SInt_fuse1 =
  proc ()
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let ann#cc40f3dcd14927decb69fc86af066439772650ab76dfb9a3483879be91560789 : Allocation = fuse1.
  let mk_tensor2 = (\ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  ( @ p0 (c0)
  | @ p1 (c1))).
  let p#5554dd5f470e6ed0f2e5fbc1e4c23a5f4dd5b16757bbe563455768a667b6e00c : < S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c'#p : !Int)
  c'#p <- 42).
  let q#74dbc8252fe888ddf597a3487bdf98df293e4d0fe41379412212e047ab1859b3 : < ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (d#q : ?Int)
  let x#q : Int <- d#q).
  let S1#1dbf20ff644fdad3e47918591ef9ed1ca79b13e3816d109e025eb585eef86af0 : Session = (~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a).
  let x#q : Int = 42.
  new/alloc [c : [: :], d : [: :]]

com_new_mk_ten2_SInt_fuse2 =
  proc ()
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let ann#5c17eb5b88064ce5775fe297433913ed0646e660ef86644367d803be0a911af8 : Allocation = fuse2.
  let mk_tensor2 = (\ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  ( @ p0 (c0)
  | @ p1 (c1))).
  let p#5554dd5f470e6ed0f2e5fbc1e4c23a5f4dd5b16757bbe563455768a667b6e00c : < S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c'#p : !Int)
  c'#p <- 42).
  let q#74dbc8252fe888ddf597a3487bdf98df293e4d0fe41379412212e047ab1859b3 : < ~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (d#q : ?Int)
  let x#q : Int <- d#q).
  let S1#1dbf20ff644fdad3e47918591ef9ed1ca79b13e3816d109e025eb585eef86af0 : Session = (~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a).
  let x#q : Int = 42

conv_fun =
  \ (A : Type)-> \ (A' : Type)-> \ (B : Type)-> \ (S : Session)-> \ (dom : A' -> A)-> \ (cod : B -> < S >)-> \ (f : A -> B)-> proc (c : {?A', S})
  split c {i, o}.
  let p : A' <- i.
  @ (cod (f (dom p)))(o)

curry =
  \ (S : Session)-> \ (T : Session)-> \ (U : Session)-> proc (c : {[[S, T],~ U],{~ S, {~ T, U}}})
  split c {f, xyo}.
  split xyo {x, yo}.
  split yo {y, o}.
  split f [fxy, fo].
  split fxy [fx, fy].
  ( fwd S (fx, x)
  | fwd T (fy, y)
  | fwd U (o, fo))

curry_SInt_SBool_SDouble =
  let S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = !Int in
  let T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7 : Session = !Bool in
  let U#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d : Session = !Double in
  proc (c : {[[S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7],~ U#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d],{~ S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, {~ T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7, U#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d}}})
  split c {f, xyo}.
  split xyo {x, yo}.
  split yo {y, o}.
  split f [fxy, fo].
  split fxy [fx, fy].
  fwd S#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a (fx, x).
  fwd T#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7 (fy, y).
  fwd U#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d (o, fo)

cutEmptyParTensor =
  proc ()
  ( )

cut_par_cut =
  proc ()
  let x : Int = 1.
  let x' : Int = 1

cut_recv_send_send_recv =
  proc ()
  let y : Int = 1.
  let x : Int = 2

cutSendRecv =
  proc ()
  let x : Int = 1

cut_send_recv_recv_send =
  proc ()
  let y : Int = 1.
  let x : Int = 2

cut_send_recv_recv_send_v2 =
  proc ()
  let y : Int = 1.
  let x : Int = 2

cut_send_recv_recv_send_with_log =
  proc (logc : !String.!String, logd : !String.!String)
  logd <- "recv d".
  logc <- "send c 1".
  let y : Int = 1.
  logc <- "recv c".
  logd <- "send d 2".
  let x : Int = 2

cut_send_recv_recv_send_with_log_prll =
  proc (logc : !String.!String, logd : !String.!String)
  logd <- "recv d".
  logc <- "send c 1".
  let y : Int = 1.
  logc <- "recv c".
  logd <- "send d 2".
  let x : Int = 2

dep_fun_server =
  \ (A : Type)-> \ (B : (x : A)-> Type)-> \ (f : (x : A)-> B x)-> proc (c : ?(x : A).!B x)
  let x : A <- c.
  c <- (f x)

div_mod_server_cont =
  proc (c : ?Int.?Int.!Int.!Int)
  let m : Int <- c.
  let n : Int <- c.
  c <- (m / n).
  c <- (m % n)

div_mod_server_explicit_prll =
  proc (rm : ?Int, rn : ?Int, sdiv : !Int, smod : !Int)
  let n : Int <- rn.
  let m : Int <- rm.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_par2_ten2_ten2 =
  proc (r : [?Int, ?Int],s : [!Int, !Int])
  split r [rm, rn].
  split s [sdiv, smod].
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_par4 =
  proc (c : {?Int, ?Int, !Int, !Int})
  split c {rm, rn, sdiv, smod}.
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_seq2_ten2_ten2 =
  proc (c : [: [?Int, ?Int],[!Int, !Int]:])
  split c [: r, s :].
  split r [rm, rn].
  split s [sdiv, smod].
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_seq4 =
  proc (c : [: ?Int, ?Int, !Int, !Int :])
  split c [: rm, rn, sdiv, smod :].
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

div_mod_server_simple =
  proc (rm : ?Int, rn : ?Int, sdiv : !Int, smod : !Int)
  let m : Int <- rm.
  let n : Int <- rn.
  sdiv <- (m / n).
  smod <- (m % n)

double =
  proc (a : ?Int, b : !Int)
  let x : Int <- a.
  b <- (x + x)

double_21 =
  proc (b : !Int)
  let x : Int = 21.
  b <- (x + x)

double_21_seq =
  proc (b : !Int)
  let x : Int = 21.
  b <- (x + x)

double_21_fused =
  proc (b : !Int)
  let x : Int = 21.
  b <- (x + x)

double_21_fused_and_reduced =
  proc (b : !Int)
  b <- 42

another_dual =
  \ (S : Session)-> ~ S

dual_dual =
  \ (S : Session)-> \ (p : < S >)-> proc (c : ~ another_dual S)
  @ p (c)

send_42 =
  proc (c : !Int)
  c <- 42

embed_send_42 =
  proc (c : !Int)
  c <- 42

my_zero =
  0

assert
  (S : Session)-> (T : Session)-> < S ^ 5, T ^ (0 + my_zero)>
  =
  (S : Session)-> (T : Session)-> < S ^ 2, T ^ 0, S, S, S >
  : Type

assert
  (S : Session)-> (m : Int)-> (n : Int)-> < S ^ (m + n)>
  =
  (S : Session)-> (m : Int)-> (n : Int)-> < S ^ m, S ^ n >
  : Type

fake_div_mod_server_ten2 =
  proc (r : [?Int, ?Int],s : [!Int, !Int])
  split r [rm, rn].
  split s [sdiv, smod].
  sdiv <- 42.
  smod <- 21.
  let m : Int <- rm.
  let n : Int <- rn

feed_fwd_send_then_recv =
  \ (I : Type)-> \ (O : Type)-> \ (i : I)-> \ (f : (x : I)-> O)-> \ (p : < !I.?O, ?I.!O >)-> proc ()
  new [a : {!I.?O, ?I.!O},b : [?I.!O, !I.?O]].
  ( @ p (a)
  | split b [c, d].
    ( let x : I <- c.
      c <- (f x)
    | d <- i.
      let o : O <- d ))

feed_fwd_send_then_recv_Int_String_42_showInt =
  proc ()
  let I#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 : Type = Int.
  let O#bb5abe4af97aa08dbca3d789ebb338e0abd7cfc9d203f202e95d25c0f305ca6d : Type = String.
  let f#17b9fb41aa66331327e227ae125d4079dcee67ed6f9c0d5ff77f4dede08ff85d : (x#f : I#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2)-> O#bb5abe4af97aa08dbca3d789ebb338e0abd7cfc9d203f202e95d25c0f305ca6d = showInt.
  let i#1b38768212e0ec952e7048820f4309b9fa2609b6388a3e7bc2f44e126fec1bad : I#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 = 42.
  let p#25afafdad7674321b2eb29d69d32dd06d5e9e6605904caa82c9b3e5b13876dd9 : < !I#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2.?O#bb5abe4af97aa08dbca3d789ebb338e0abd7cfc9d203f202e95d25c0f305ca6d, ?I#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2.!O#bb5abe4af97aa08dbca3d789ebb338e0abd7cfc9d203f202e95d25c0f305ca6d > = (proc (c#p)
  split c#p {c#0#p : !Int.?String, c#1#p : ?Int.!String}.
  let x#c#1#p : Int <- c#1#p.
  c#0#p <- x#c#1#p.
  let x#c#0#p : String <- c#0#p.
  c#1#p <- x#c#0#p).
  let x#c#1#p : Int = i#1b38768212e0ec952e7048820f4309b9fa2609b6388a3e7bc2f44e126fec1bad.
  let x : I#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 = x#c#1#p.
  let x#c#0#p : String = (f#17b9fb41aa66331327e227ae125d4079dcee67ed6f9c0d5ff77f4dede08ff85d x).
  let o : O#bb5abe4af97aa08dbca3d789ebb338e0abd7cfc9d203f202e95d25c0f305ca6d = x#c#0#p

feed_recv =
  \ (p : < ?Int >)-> \ (i : Int)-> proc ()
  new [c : ?Int, d].
  ( @ p (c)
  | d <- i )

feed_send =
  \ (p : < !Int >)-> proc ()
  new [c : !Int, d].
  ( @ p (c)
  | let x : Int <- d )

feed_send_par_recv =
  \ (p : < !Int, ?Int >)-> \ (n : Int)-> proc ()
  new [c : {!Int, ?Int},d : [?Int, !Int]].
  ( @ p (c)
  | split d [i, o].
    ( let x : Int <- i
    | o <- n ))

feed_send_ten_recv =
  \ (p : < [!Int, ?Int]>)-> \ (f : (x : Int)-> Int)-> proc ()
  new [c : [!Int, ?Int],d : {?Int, !Int}].
  ( @ p (c)
  | split d {i, o}.
    let x : Int <- i.
    o <- (f x))

feed_send_then_recv =
  \ (p : < !Int.?Int >)-> \ (f : (x : Int)-> Int)-> proc ()
  new [c : !Int.?Int, d].
  ( @ p (c)
  | let x : Int <- d.
    d <- (f x))

flexible_telescope : (A : Type)-> (B : Type)-> (x : A)-> (y : A)-> (z : B)-> (t : B)-> Int =
  \ (A : Type)-> \ (B : Type)-> \ (x : A)-> \ (y : A)-> \ (z : B)-> \ (t : B)-> 42

fun1_to_proc_ord =
  \ (I : Type)-> \ (O : Type)-> \ (f : (x : I)-> O)-> proc (c : [: ?I, !O :])
  split c [: i, o :].
  let x : I <- i.
  o <- (f x)

fun1_to_proc_par2 =
  \ (I : Type)-> \ (O : Type)-> \ (f : (x : I)-> O)-> proc (i : ?I, o : !O)
  let x : I <- i.
  o <- (f x)

fun1_to_proc_seq =
  \ (I : Type)-> \ (O : Type)-> \ (f : (x : I)-> O)-> proc (c : ?I.!O)
  let x : I <- c.
  c <- (f x)

fwd0_snd0 =
  proc (c : {})
  split c {}

fwd1_rcv =
  proc (c : {?Int})
  split c {c#0 : ?Int}.
  let x#c#0 : Int <- c#0

fwd2_par2_ten2 =
  proc (c : {{?Int, !Int.?Int},[!Int, ?Int.!Int]})
  split c {c#0 : {?Int, !Int.?Int},c#1 : [!Int, ?Int.!Int]}.
  split c#0 {c#0#0 : ?Int, c#0#1 : !Int.?Int}.
  split c#1 [c#1#0 : !Int, c#1#1 : ?Int.!Int].
  let x#c#0#0 : Int <- c#0#0.
  let x#c#1#1 : Int <- c#1#1.
  c#1#0 <- x#c#0#0.
  c#0#1 <- x#c#1#1.
  let x#c#0#1 : Int <- c#0#1.
  c#1#1 <- x#c#0#1

fwd3_par2_ten2_ten2 =
  proc (c : {{?Int, !Int.?Int},[!Int, ?Int.!Int],{!Int, !Int.!Int}})
  split c {c#0 : {?Int, !Int.?Int},c#1 : [!Int, ?Int.!Int],c#2 : {!Int, !Int.!Int}}.
  split c#0 {c#0#0 : ?Int, c#0#1 : !Int.?Int}.
  split c#1 [c#1#0 : !Int, c#1#1 : ?Int.!Int].
  split c#2 {c#2#0 : !Int, c#2#1 : !Int.!Int}.
  let x#c#0#0 : Int <- c#0#0.
  let x#c#1#1 : Int <- c#1#1.
  c#1#0 <- x#c#0#0.
  c#2#0 <- x#c#0#0.
  c#0#1 <- x#c#1#1.
  c#2#1 <- x#c#1#1.
  let x#c#0#1 : Int <- c#0#1.
  c#1#1 <- x#c#0#1.
  c#2#1 <- x#c#0#1

fwd3_seq2_seq2_seq2 =
  proc (c : {[: ?Int, !Int.?Int :], [: !Int, ?Int.!Int :], [: !Int, !Int.!Int :]})
  split c {c#0 : [: ?Int, !Int.?Int :], c#1 : [: !Int, ?Int.!Int :], c#2 : [: !Int, !Int.!Int :]}.
  split c#0 [: c#0#0 : ?Int, c#0#1 : !Int.?Int :].
  split c#1 [: c#1#0 : !Int, c#1#1 : ?Int.!Int :].
  split c#2 [: c#2#0 : !Int, c#2#1 : !Int.!Int :].
  let x#c#0#0 : Int <- c#0#0.
  c#1#0 <- x#c#0#0.
  c#2#0 <- x#c#0#0.
  let x#c#1#1 : Int <- c#1#1.
  c#0#1 <- x#c#1#1.
  c#2#1 <- x#c#1#1.
  let x#c#0#1 : Int <- c#0#1.
  c#1#1 <- x#c#0#1.
  c#2#1 <- x#c#0#1

fwd_par0_ten0 =
  proc (i : {}, o : [])
  split i {}.
  split o []

fwd_par2_ten2_expanded =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int])
  split o [o0, o1].
  split i {i0, i1}.
  let xi0 : Int <- i0.
  let xo1 : Int <- o1.
  o0 <- xi0.
  i1 <- xo1.
  let xi1 : Int <- i1.
  o1 <- xi1

fwd_par2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int])
  split i {i#0 : ?Int, i#1 : !Int.?Int}.
  split o [o#0 : !Int, o#1 : ?Int.!Int].
  let x#i#0 : Int <- i#0.
  let x#o#1 : Int <- o#1.
  o#0 <- x#i#0.
  i#1 <- x#o#1.
  let x#i#1 : Int <- i#1.
  o#1 <- x#i#1

fwd_par2_ten2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int],l : {!Int, !Int.!Int})
  split i {i#0 : ?Int, i#1 : !Int.?Int}.
  split o [o#0 : !Int, o#1 : ?Int.!Int].
  split l {l#0 : !Int, l#1 : !Int.!Int}.
  let x#i#0 : Int <- i#0.
  let x#o#1 : Int <- o#1.
  o#0 <- x#i#0.
  l#0 <- x#i#0.
  i#1 <- x#o#1.
  l#1 <- x#o#1.
  let x#i#1 : Int <- i#1.
  o#1 <- x#i#1.
  l#1 <- x#i#1

fwd_par2_ten2_ten2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int],l : {!Int, !Int.!Int},m : {!Int, !Int.!Int})
  split i {i#0 : ?Int, i#1 : !Int.?Int}.
  split o [o#0 : !Int, o#1 : ?Int.!Int].
  split l {l#0 : !Int, l#1 : !Int.!Int}.
  split m {m#0 : !Int, m#1 : !Int.!Int}.
  let x#i#0 : Int <- i#0.
  let x#o#1 : Int <- o#1.
  o#0 <- x#i#0.
  l#0 <- x#i#0.
  m#0 <- x#i#0.
  i#1 <- x#o#1.
  l#1 <- x#o#1.
  m#1 <- x#o#1.
  let x#i#1 : Int <- i#1.
  o#1 <- x#i#1.
  l#1 <- x#i#1.
  m#1 <- x#i#1

fwd_send_recv =
  proc (i : ?Int, o : !Int)
  let x#i : Int <- i.
  o <- x#i

fwd_send_recv_recv_auto =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int)
  let x#d : Int <- d.
  c <- x#d.
  let x#c : Int <- c.
  d <- x#c.
  let y#c : Int <- c.
  d <- y#c

fwd_send_recv_recv_manually =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int)
  let x : Int <- d.
  c <- x.
  let y : Int <- c.
  d <- y.
  let z : Int <- c.
  d <- z

fwd_send_recv_recv_send =
  proc (i : ?Int.!Int, o : !Int.?Int)
  let x#i : Int <- i.
  o <- x#i.
  let x#o : Int <- o.
  i <- x#o

fwd_send_recv_recv_with_listener_auto =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int, e : !Int.!Int.!Int)
  let x#d : Int <- d.
  c <- x#d.
  e <- x#d.
  let x#c : Int <- c.
  d <- x#c.
  e <- x#c.
  let y#c : Int <- c.
  d <- y#c.
  e <- y#c

fwd_send_recv_recv_with_listener_manually =
  proc (c : !Int.?Int.?Int, d : ?Int.!Int.!Int, e : !Int.!Int.!Int)
  let x : Int <- d.
  c <- x.
  e <- x.
  let y : Int <- c.
  d <- y.
  e <- y.
  let z : Int <- c.
  d <- z.
  e <- z

fwd_seq2_seq2_seq2 =
  proc (i : [: ?Int, !Int.?Int :], o : [: !Int, ?Int.!Int :], l : [: !Int, !Int.!Int :])
  split i [: i#0 : ?Int, i#1 : !Int.?Int :].
  split o [: o#0 : !Int, o#1 : ?Int.!Int :].
  split l [: l#0 : !Int, l#1 : !Int.!Int :].
  let x#i#0 : Int <- i#0.
  o#0 <- x#i#0.
  l#0 <- x#i#0.
  let x#o#1 : Int <- o#1.
  i#1 <- x#o#1.
  l#1 <- x#o#1.
  let x#i#1 : Int <- i#1.
  o#1 <- x#i#1.
  l#1 <- x#i#1

fwd_ten2_par2 =
  proc (i : [?Int, !Int.?Int],o : {!Int, ?Int.!Int})
  split i [i#0 : ?Int, i#1 : !Int.?Int].
  split o {o#0 : !Int, o#1 : ?Int.!Int}.
  let x#i#0 : Int <- i#0.
  let x#o#1 : Int <- o#1.
  o#0 <- x#i#0.
  i#1 <- x#o#1.
  let x#i#1 : Int <- i#1.
  o#1 <- x#i#1

split_nested_seq_core =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (D : Session)-> proc (i : [: ~ A, ~ B, ~ C, ~ D :], o : [: [: A, B :], [: C, D :] :])
  split i [: na, nb, nc, nd :].
  split o [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  fwd A (a, na).
  fwd B (b, nb).
  fwd C (c, nc).
  fwd D (d, nd)

group_nested_seq : (A : Session)-> (B : Session)-> (C : Session)-> (D : Session)-> < [: [: ~ A, ~ B :], [: ~ C, ~ D :] :], [: A, B, C, D :] > =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (D : Session)-> proc (c : {[: [: ~ A, ~ B :], [: ~ C, ~ D :] :], [: A, B, C, D :]})
  split c {i, o}.
  @ (split_nested_seq_core (~ A)(~ B)(~ C)(~ D)) {o, i}

group_nested_seq_SInt_SDouble_SBool_SString =
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = !Int in
  let B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d : Session = !Double in
  let C#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7 : Session = !Bool in
  let D#792ac0c449e352da13cf47b915952a7bf1a805a1908f38d163f7c2324099f0f1 : Session = !String in
  proc (c : {[: [: ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d :], [: ~ C#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7, ~ D#792ac0c449e352da13cf47b915952a7bf1a805a1908f38d163f7c2324099f0f1 :] :], [: A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d, C#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7, D#792ac0c449e352da13cf47b915952a7bf1a805a1908f38d163f7c2324099f0f1 :]})
  let A#264d12f0701178b3d57928a82453a0dc2a0ebf22a6bcf05fd1536162c14afc71 : Session = (~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a).
  let B#f1b43f28891ec876418e998b7e9202d637c7ed09a7956ca8c99b28979e648196 : Session = (~ B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d).
  let C#caadb9df3bdf995155876e4594ccf799bab5dffa34b71e48de3a01d76d97ce79 : Session = (~ C#e884e9a9974068331e1e0bd466dcc0bd9bfccf1dc0ef31a855ecae48dca3e6f7).
  let D#870a4ccf0d13e883210d8bda9b102dda116e5c30942d73c125f129615baf54ed : Session = (~ D#792ac0c449e352da13cf47b915952a7bf1a805a1908f38d163f7c2324099f0f1).
  split c {i, o}.
  split o [: na, nb, nc, nd :].
  split i [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  fwd A#264d12f0701178b3d57928a82453a0dc2a0ebf22a6bcf05fd1536162c14afc71 (a, na).
  fwd B#f1b43f28891ec876418e998b7e9202d637c7ed09a7956ca8c99b28979e648196 (b, nb).
  fwd C#caadb9df3bdf995155876e4594ccf799bab5dffa34b71e48de3a01d76d97ce79 (c, nc).
  fwd D#870a4ccf0d13e883210d8bda9b102dda116e5c30942d73c125f129615baf54ed (d, nd)

idProc =
  proc (c : ?Int, d : !Int)
  let y : Int <- c.
  d <- (id Int y)

assert
  42
  =
  let x = 42 in
  x


i42 : Int =
  42

one : Int =
  1

suc : (x : Int)-> Int =
  _+_ one

doubleInt : (x : Int)-> Int =
  \ (x : Int)-> x + x

data ABC = `a | `b | `c

rot : (x : ABC)-> ABC =
  \ (x : ABC)-> case x of {
    `a -> `b ,
    `b -> `c ,
    `c -> `a
  }

rot2 : (x : ABC)-> ABC =
  \ (x : ABC)-> rot (rot x)

let42ann =
  let x : Int = 42 in
  x + x

let42 =
  let x = 42 in
  x + x

let_example =
  let T = Int in
  let f = _+_ in
  proc (c : ?T.!T)
  let x : T <- c.
  let y = (f x x).
  c <- y

let_in_proc_for_session =
  proc (c : ?Int)
  let A = Int.
  let x : A <- c

letnewchan =
  proc ()
  let T = Int.
  let x : T = 42.
  let y : T = (x + x)

let_order =
  let x = 1 in
  let y = 2 in
  x + y

let_order_proc =
  proc (c : !Int)
  let x = 1.
  let y = 2.
  c <- (x + y)

letrecv_ann =
  proc (c : ?Int.!Int)
  let x : Int <- c.
  let y : Int = (x + x).
  c <- y

letrecv =
  proc (c : ?Int.!Int)
  let x : Int <- c.
  let y = (x + x).
  c <- y

letsession =
  let f = \ (S0 : Session)-> let S1 = {S0, S0}in
  let S2 = {S1, S1}in
  let S3 = {S2, S2}in
  let S4 = {S3, S3}in
  let S5 = {S4, S4}in
  let S6 = {S5, S5}in
  let S7 = {S6, S6}in
  S7 in
  proc (c)
  split c {c#0 : f (?Int),c#1 : ~ f (?Int)}.
  fwd (f (?Int)) (c#0, c#1)

lettype : (P : (A : Type)-> (B : Type)-> Type)-> (p : (A : Type)-> P A A)-> (A : Type)-> P (P (P (P A A)(P A A)) (P (P A A)(P A A)))(P (P (P A A)(P A A)) (P (P A A)(P A A)))=
  \ (P : (A : Type)-> (B : Type)-> Type)-> \ (p : (A : Type)-> P A A)-> \ (A : Type)-> let B = P A A in
  let C = P B B in
  let D = P C C in
  p D

assert
  1
  =
  let f = \ (x : Int)-> x in
  f (f 1)
  : Int

showMult =
  \ (m : Int)-> \ (n : Int)-> (showInt m)++S " * " ++S (showInt n)++S " = " ++S showInt (m * n)

showDiv =
  \ (m : Double)-> \ (n : Double)-> (showDouble m)++S " / " ++S (showDouble n)++S " = " ++S showDouble (m /D n)

my42 : String =
  showMult 2 21

my3_14 : String =
  showDiv 6.28 2.0

myNewline : Char =
  '\n'

mkfwd =
  \ (A : Session)-> proc (a : A, na : ~ A)
  fwd A (a, na)

loli_id : (A : Session)-> < ~ A, A > =
  \ (A : Session)-> proc (naa : {~ A, A})
  split naa {na, a}.
  @ (mkfwd (~ A)) {na, a}

loli_id_SInt =
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = !Int in
  proc (naa : {~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a})
  let A#264d12f0701178b3d57928a82453a0dc2a0ebf22a6bcf05fd1536162c14afc71 : Session = (~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a).
  split naa {na, a}.
  fwd A#264d12f0701178b3d57928a82453a0dc2a0ebf22a6bcf05fd1536162c14afc71 (na, a)

zipWith =
  \ (A : Type)-> \ (B : Type)-> \ (C : Type)-> \ (f : (a : A)-> (b : B)-> C)-> \ (n : Int)-> proc (cas : [: ?A ^ n :], cbs : [: ?B ^ n :], ccs : [: !C ^ n :])
  split cas [: ca ^ n :].
  split cbs [: cb ^ n :].
  split ccs [: cc ^ n :].
  sequence ^ n
    (let a : A <- ca.
    let b : B <- cb.
    cc <- (f a b))

zip_multD =
  zipWith Double Double Double _*D_

foldl =
  \ (A : Type)-> \ (B : Type)-> \ (f : (acc : B)-> (a : A)-> B)-> \ (init : B)-> \ (n : Int)-> proc (ca : [: ?A ^ n :], cr : !B)
  new/alloc (acc :* B).
  acc <- init.
  split acc [: acci ^ n, accn :].
  split ca [: ai ^ n :].
  (sequence ^ n
    (( let a : A <- ai
    | let b : B <- acci ).
    acci <- (f b a)) ).
  let x#accn : B <- accn.
  cr <- x#accn

sumD : (n : Int)-> < [: ?Double ^ n :], !Double > =
  foldl Double Double _+D_ 0.0

dotproduct =
  \ (n : Int)-> \ (ann : Allocation)-> proc (as' : [: ?Double ^ n :], bs : [: ?Double ^ n :], o : !Double)
  new/ann [: cs : [: !Double ^ n :], ds :].
  @ (zip_multD n){as', bs, cs}.
  @ (sumD n){ds, o}

dotproduct_4_alloc =
  let ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc in
  let n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 : Int = 4 in
  proc (as' : [: ?Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], bs : [: ?Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], o : !Double)
  let A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let C#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let f#8e0d827ff373ce6d968c5468bab8e2e4d06dcfdc4d713d097129586ed21f1a6c : (acc#f : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> (a#f : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = _+D_.
  let f#dbab05df58de62d874fb098cf9bfeca6169ba054f04850f38b9a36b20c9dde1a : (a#f : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> (b#f : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> C#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = _*D_.
  let init#91b8e97e1c981514c5a72c3926c92866cb48b9b10b8f0b2e1dc50bed4df5c89d : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = 0.0.
  new/ann#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [: cs : [: !Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], ds :].
  split as' [: ca ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
  split bs [: cb ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
  split cs [: cc ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
  (sequence ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9
    (let a : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- ca.
    let b : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- cb.
    cc <- (f#dbab05df58de62d874fb098cf9bfeca6169ba054f04850f38b9a36b20c9dde1a a b)) ).
  new/alloc (acc :* B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab).
  acc <- init#91b8e97e1c981514c5a72c3926c92866cb48b9b10b8f0b2e1dc50bed4df5c89d.
  split acc [: acci ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9, accn :].
  split ds [: ai ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
  (sequence ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9
    (let a : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- ai.
    let b : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- acci.
    acci <- (f#8e0d827ff373ce6d968c5468bab8e2e4d06dcfdc4d713d097129586ed21f1a6c b a)) ).
  let x#accn : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- accn.
  o <- x#accn

dotproduct_4_fused =
  let ann#47d781f2688eff35434d58e35a537991b5fbfe16841a1609843ae641af58792b : Allocation = fused in
  let n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 : Int = 4 in
  proc (as' : [: ?Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], bs : [: ?Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], o : !Double)
  let A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let C#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let f#8e0d827ff373ce6d968c5468bab8e2e4d06dcfdc4d713d097129586ed21f1a6c : (acc#f : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> (a#f : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = _+D_.
  let f#dbab05df58de62d874fb098cf9bfeca6169ba054f04850f38b9a36b20c9dde1a : (a#f : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> (b#f : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> C#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = _*D_.
  let init#91b8e97e1c981514c5a72c3926c92866cb48b9b10b8f0b2e1dc50bed4df5c89d : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = 0.0.
  split as' [: ca ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
  split bs [: cb ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
  (sequence ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9
    (let a : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- ca.
    let b : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- cb.
    let a : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = (f#dbab05df58de62d874fb098cf9bfeca6169ba054f04850f38b9a36b20c9dde1a a b)) ).
  new/alloc (acc :* B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab).
  acc <- init#91b8e97e1c981514c5a72c3926c92866cb48b9b10b8f0b2e1dc50bed4df5c89d.
  split acc [: acci ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9, accn :].
  (sequence ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9
    (let b : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- acci.
    acci <- (f#8e0d827ff373ce6d968c5468bab8e2e4d06dcfdc4d713d097129586ed21f1a6c b a)) ).
  let x#accn : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- accn.
  o <- x#accn

ix : (A : Type)-> (n : Int)-> (v : Vec A n)-> (i : Int)-> A

row =
  \ (A : Type)-> \ (m : Int)-> \ (n : Int)-> \ (a : Vec A (m * n)) -> \ (i : Int)-> proc (v : [: !A ^ n :])
  split v [: v_i ^ n :].
  sequence ^ n with j
    v_i <- (ix A (m * n)a ((i * n)+ j))

col =
  \ (A : Type)-> \ (m : Int)-> \ (n : Int)-> \ (a : Vec A (m * n)) -> \ (j : Int)-> proc (v : [: !A ^ m :])
  split v [: v_j ^ m :].
  sequence ^ m with i
    v_j <- (ix A (m * n)a ((i * n)+ j))

matmult =
  \ (m : Int)-> \ (n : Int)-> \ (p : Int)-> \ (ann0 : Allocation)-> \ (ann1 : Allocation)-> \ (ann2 : Allocation)-> proc (a : ?Vec Double (m * n),b : ?Vec Double (n * p),c : [: !Double ^ (m * p):])
  let a' : Vec Double (m * n)<- a.
  let b' : Vec Double (n * p)<- b.
  split c [: c_i_j ^ (m * p):].
  sequence ^ (m * p)with ij
    (new/ann0 [: u : [: !Double ^ n :], u' :].
    @ (row Double m n a' (ij / n)) (u).
    new/ann1 [: v : [: !Double ^ n :], v' :].
    @ (col Double n p b' (ij % n)) (v).
    let nn = n.
    @ (dotproduct nn ann2){u', v', c_i_j})

matmult_4_alloc =
  let ann0#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc in
  let ann1#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc in
  let ann2#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc : Allocation = alloc in
  let m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 : Int = 4 in
  let n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 : Int = 4 in
  let p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 : Int = 4 in
  proc (a : ?Vec Double (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9),b : ?Vec Double (n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9),c : [: !Double ^ (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9):])
  let A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let a#78179c1f7960c2583776bc879ef8af0eb21b9e3a78b93ff2303b72544a504572 : Vec A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab (n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)= b'.
  let a#d5960e7cd6c4de08f6585a101a84e659e5ba6a9b23cc837742ea57b3684019db : Vec A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)= a'.
  let i#56ab9e04ef279c47ab4f8ebd4465af022b0953dea1b7c48a55b840666826ff59 : Int = (ij / n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9).
  let j#f232b2e0485baea290ef1eff812ce00ab02e1cb19c1525879d5086ff4e9ecc16 : Int = (ij % n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9).
  let n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e : Int = nn.
  let a' : Vec Double (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)<- a.
  let A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let C#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab : Type = Double.
  let f#8e0d827ff373ce6d968c5468bab8e2e4d06dcfdc4d713d097129586ed21f1a6c : (acc#f : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> (a#f : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = _+D_.
  let f#dbab05df58de62d874fb098cf9bfeca6169ba054f04850f38b9a36b20c9dde1a : (a#f : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> (b#f : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab)-> C#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = _*D_.
  let init#91b8e97e1c981514c5a72c3926c92866cb48b9b10b8f0b2e1dc50bed4df5c89d : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab = 0.0.
  let b' : Vec Double (n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)<- b.
  split c [: c_i_j ^ (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9):].
  sequence ^ (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)with ij
    (new/ann0#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [: u : [: !Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], u' :].
    split u [: v_i ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
    (sequence ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 with j
      v_i <- (ix A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab (m#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)a#d5960e7cd6c4de08f6585a101a84e659e5ba6a9b23cc837742ea57b3684019db ((i#56ab9e04ef279c47ab4f8ebd4465af022b0953dea1b7c48a55b840666826ff59 * n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)+ j)) ).
    new/ann1#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [: v : [: !Double ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :], v' :].
    split v [: v_j ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 :].
    (sequence ^ n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 with i
      v_j <- (ix A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab (n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9 * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)a#78179c1f7960c2583776bc879ef8af0eb21b9e3a78b93ff2303b72544a504572 ((i * p#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9)+ j#f232b2e0485baea290ef1eff812ce00ab02e1cb19c1525879d5086ff4e9ecc16)) ).
    let nn = n#9b0fd9c8f1862702ba20da045df8f1a50e437cad43e11db966941fc57aff46a9.
    new/ann2#6bc3cda78e0b38f1cc66f91fea469a35d39e924b5d30307ed336b7624e7ba7dc [: cs : [: !Double ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e :], ds :].
    split u' [: ca ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e :].
    split v' [: cb ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e :].
    split cs [: cc ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e :].
    (sequence ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e
      (let a : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- ca.
      let b : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- cb.
      cc <- (f#dbab05df58de62d874fb098cf9bfeca6169ba054f04850f38b9a36b20c9dde1a a b)) ).
    new/alloc (acc :* B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab).
    acc <- init#91b8e97e1c981514c5a72c3926c92866cb48b9b10b8f0b2e1dc50bed4df5c89d.
    split acc [: acci ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e, accn :].
    split ds [: ai ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e :].
    (sequence ^ n#607f4c171ce9d41867051267c6cab642c93319eee6b115d436274dd08e2d468e
      (let a : A#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- ai.
      let b : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- acci.
      acci <- (f#8e0d827ff373ce6d968c5468bab8e2e4d06dcfdc4d713d097129586ed21f1a6c b a)) ).
    let x#accn : B#6195445550164ff88a795bf40158f1d2b9d7dcc832a2fa0d514f405b621fb6ab <- accn.
    c_i_j <- x#accn)

merger =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : [!Vec Int m, ?Vec Int m],c1 : [!Vec Int n, ?Vec Int n],ci : ?Vec Int (m + n),co : !Vec Int (m + n))
  split c0 [c0i, c0o].
  split c1 [c1i, c1o].
  let vi : Vec Int (m + n)<- ci.
  ( c0i <- (take Int m n vi)
  | c1i <- (drop Int m n vi)
  | let v0 : Vec Int m <- c0o.
    let v1 : Vec Int n <- c1o.
    co <- (merge m n v0 v1))

merger_loli_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {[~ DotSort Int m, ~ DotSort Int n],DotSort Int (m + n)})
  split c {c01, d}.
  split c01 [c0, c1].
  let vi : Vec Int (m + n)<- d.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  d <- (merge m n v0 v1)

merger_nstSort_prll =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : ~ DotSort Int m, c1 : ~ DotSort Int n, c : DotSort Int (m + n))
  let vi : Vec Int (m + n)<- c.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  c <- (merge m n v0 v1)

merger_nstSort_prll_v2 =
  \ (m : Int)-> \ (n : Int)-> proc (c : [~ DotSort Int m, ~ DotSort Int n],d : DotSort Int (m + n))
  split c [c0, c1].
  let vi : Vec Int (m + n)<- d.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  d <- (merge m n v0 v1)

merger_ParSort_full_prll =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : ~ ParSort Int m, c1 : ~ ParSort Int n, c : ParSort Int (m + n))
  split c0 [c0i, c0o].
  split c1 [c1i, c1o].
  split c {ci, co}.
  let vi : Vec Int (m + n)<- ci.
  ( c0i <- (take Int m n vi)
  | c1i <- (drop Int m n vi)
  | ( let v0 : Vec Int m <- c0o
    | let v1 : Vec Int n <- c1o ).
    co <- (merge m n v0 v1))

merger_seq_inferred =
  \ (m : Int)-> \ (n : Int)-> proc (c0, c1, ci, co)
  let vi : Vec Int (m + n)<- ci.
  c0 <- (take Int m n vi).
  c1 <- (drop Int m n vi).
  let v0 : Vec Int m <- c0.
  let v1 : Vec Int n <- c1.
  co <- (merge m n v0 v1)

merger_seq =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : !Vec Int m.?Vec Int m, c1 : !Vec Int n.?Vec Int n, ci : ?Vec Int (m + n),co : !Vec Int (m + n))
  let vi : Vec Int (m + n)<- ci.
  c0 <- (take Int m n vi).
  c1 <- (drop Int m n vi).
  let v0 : Vec Int m <- c0.
  let v1 : Vec Int n <- c1.
  co <- (merge m n v0 v1)

merger_seq_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{~ DotSort Int m, ~ DotSort Int n},DotSort Int (m + n)})
  split c {d, io}.
  split d {d0, d1}.
  let vi : Vec Int (m + n)<- io.
  d0 <- (take Int m n vi).
  d1 <- (drop Int m n vi).
  let v0 : Vec Int m <- d0.
  let v1 : Vec Int n <- d1.
  io <- (merge m n v0 v1)

merger_seqential_ten2_loli_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{~ DotSort Int m, ~ DotSort Int n},DotSort Int (m + n)})
  split c {c01, d}.
  split c01 {c0, c1}.
  let vi : Vec Int (m + n)<- d.
  c0 <- (take Int m n vi).
  c1 <- (drop Int m n vi).
  let v0 : Vec Int m <- c0.
  let v1 : Vec Int n <- c1.
  d <- (merge m n v0 v1)

merger_ten2_loli_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{~ DotSort Int m, ~ DotSort Int n},DotSort Int (m + n)})
  split c {c01, d}.
  split c01 {c0, c1}.
  let vi : Vec Int (m + n)<- d.
  ( c0 <- (take Int m n vi)
  | c1 <- (drop Int m n vi)).
  ( let v0 : Vec Int m <- c0
  | let v1 : Vec Int n <- c1 ).
  d <- (merge m n v0 v1)

mk_new_ann =
  \ (ann : Allocation)-> \ (S : Session)-> \ (p : < S >)-> \ (q : < ~ S >)-> proc ()
  new/ann [c : S, d : ~ S].
  ( @ p (c)
  | @ q (d))

mk_par2_LR =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : {S0, S1})
  split c {c0, c1}.
  @ p0 (c0).
  @ p1 (c1)

mk_par2_prll =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : {S0, S1})
  split c {c0, c1}.
  ( @ p0 (c0)
  | @ p1 (c1))

mk_par2_RL =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : {S0, S1})
  split c {c0, c1}.
  @ p1 (c1).
  @ p0 (c0)

mk_seq2 =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [: S0, S1 :])
  split c [: c0, c1 :].
  @ p0 (c0).
  @ p1 (c1)

mk_ten2_2new_2fwd =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  new [d0 : ~ S0, e0 : S0].
  new [d1 : ~ S1, e1 : S1].
  ( @ p0 (e0)
  | fwd S0 (c0, d0)
  | @ p1 (e1)
  | fwd S1 (c1, d1))

mk_tensor2 =
  \ (S0 : Session)-> \ (S1 : Session)-> \ (p0 : < S0 >)-> \ (p1 : < S1 >)-> proc (c : [S0, S1])
  split c [c0, c1].
  ( @ p0 (c0)
  | @ p1 (c1))

assert
  ?(A : Type).?(B : Type).?(C : Type)
  =
  ?(A : Type).?(B : Type).?(C : Type)
  : Session

my_dual =
  \ (S : Session)-> ~ S

test_my_dual =
  proc (c : my_dual (!Int))
  let x : Int <- c

my_loli =
  \ (S : Session)-> \ (T : Session)-> {~ S, T}

test_my_loli =
  \ (A : Type)-> proc (c : my_loli (!A)(!A))
  split c {i, o}.
  let x : A <- i.
  o <- x

new_alloc =
  proc (c : !Int)
  new/alloc [d : !Int, e].
  d <- 1.
  let x#e : Int <- e.
  c <- x#e

new_ann_let_fuse_0 =
  proc ()
  let ann = (fuse 0).
  new/ann [c : [], d].
  split c [].
  split d {}

new_ann_let_fuse_1 =
  proc ()
  let ann = (fuse 1)

new_fuse1_recv_send_send_recv =
  proc ()
  let y : Int = 1.
  new/alloc [c : ?Int, d : !Int].
  d <- 2.
  let x : Int <- c

new_ten2 =
  \ (A : Session)-> \ (B : Session)-> \ (pA : < A >)-> \ (pB : < B >)-> \ (pC : < ~ A, ~ B >)-> \ (ann : Allocation)-> proc ()
  new/ann [ab : [A, B],nab : {~ A, ~ B}].
  ( split ab [a, b].
    ( @ pA (a)
    | @ pB (b))
  | @ pC (nab))

new_ten2_Int_dbl =
  new_ten2 (!Int)(?Int)(proc (c)
  c <- 42)(proc (d)
  let b : Int <- d)(proc (nab)
  split nab {na, nb}.
  let x : Int <- na.
  nb <- (x + x))

new_fuse_ten2_Int_dbl =
  \ (depth : Int)-> new_ten2_Int_dbl (fuse depth)

new_fuse0_ten2_Int_dbl =
  proc ()
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c : Session = (?Int).
  let ann#5524f65a34c0ebce45bb479607ad6a442433ca4f7066d1c0450dcd96fa4e6452 : Allocation = (fuse depth#df000b43daa8c2136eeaa8f608d1448ef689629311a74ceab830f07074e92371).
  let depth#df000b43daa8c2136eeaa8f608d1448ef689629311a74ceab830f07074e92371 : Int = 0.
  let pA#37c1609f9609eee76ac190ff4a7e5594c6a82403dfb85e6c0da41cc24468d4c5 : < A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c#pA)
  c#pA <- 42).
  let pB#31ffa47257b7d93b8afeefbe1e750446b0cd9e04fc0e3b5e229556101a4b490b : < B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (d#pB)
  let b#pB : Int <- d#pB).
  let pC#daaef59665fe2322d8ec3edfb3c8f635899cde8e3cd61a5e68051a6dd7e07443 : < ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (nab#pC)
  split nab#pC {na#pC, nb#pC}.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC)).
  new/ann#5524f65a34c0ebce45bb479607ad6a442433ca4f7066d1c0450dcd96fa4e6452 [ab : [A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c],nab : {~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c}].
  split ab [a, b].
  split nab {na#pC, nb#pC}.
  a <- 42.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC).
  let b#pB : Int <- b

new_fuse1_ten2_Int_dbl =
  proc ()
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c : Session = (?Int).
  let ann#cf13d04a8bcaae5c51c02ea4ef645b4c6f1f0ead19fa8eac212a00c7e0e7923c : Allocation = (fuse depth#eac5907587a0b6149d836091509bc82648692abaae3ea5790192a8430d57f119).
  let depth#eac5907587a0b6149d836091509bc82648692abaae3ea5790192a8430d57f119 : Int = 1.
  let pA#37c1609f9609eee76ac190ff4a7e5594c6a82403dfb85e6c0da41cc24468d4c5 : < A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c#pA)
  c#pA <- 42).
  let pB#31ffa47257b7d93b8afeefbe1e750446b0cd9e04fc0e3b5e229556101a4b490b : < B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (d#pB)
  let b#pB : Int <- d#pB).
  let pC#daaef59665fe2322d8ec3edfb3c8f635899cde8e3cd61a5e68051a6dd7e07443 : < ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (nab#pC)
  split nab#pC {na#pC, nb#pC}.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC)).
  new/alloc [a, na#pC].
  new/alloc [b, nb#pC].
  a <- 42.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC).
  let b#pB : Int <- b

new_fuse2_ten2_Int_dbl =
  proc ()
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c : Session = (?Int).
  let ann#f6e513550939f0bae417b8a22f8b631633e3fcef73440748192d1e95b1f89e80 : Allocation = (fuse depth#d0c6bb266110f2d3d8077c34cd5fc24a0d37ceec519f8c9510896d2fd5ee9b3d).
  let depth#d0c6bb266110f2d3d8077c34cd5fc24a0d37ceec519f8c9510896d2fd5ee9b3d : Int = 2.
  let pA#37c1609f9609eee76ac190ff4a7e5594c6a82403dfb85e6c0da41cc24468d4c5 : < A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c#pA)
  c#pA <- 42).
  let pB#31ffa47257b7d93b8afeefbe1e750446b0cd9e04fc0e3b5e229556101a4b490b : < B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (d#pB)
  let b#pB : Int <- d#pB).
  let pC#daaef59665fe2322d8ec3edfb3c8f635899cde8e3cd61a5e68051a6dd7e07443 : < ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (nab#pC)
  split nab#pC {na#pC, nb#pC}.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC)).
  let x#pC : Int = 42.
  new/alloc [a, na#pC].
  let b#pB : Int = (x#pC + x#pC).
  new/alloc [nb#pC, b]

new_fuse3_ten2_Int_dbl =
  proc ()
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c : Session = (?Int).
  let ann#b23525fb9071558ec377c10984cb4fb4b9fd2dc9725d918471854ba09ebd48f7 : Allocation = (fuse depth#6087f394a6fac7a83a91f48a41a7beda5c467af7d622146c485c66248a92a200).
  let depth#6087f394a6fac7a83a91f48a41a7beda5c467af7d622146c485c66248a92a200 : Int = 3.
  let pA#37c1609f9609eee76ac190ff4a7e5594c6a82403dfb85e6c0da41cc24468d4c5 : < A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c#pA)
  c#pA <- 42).
  let pB#31ffa47257b7d93b8afeefbe1e750446b0cd9e04fc0e3b5e229556101a4b490b : < B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (d#pB)
  let b#pB : Int <- d#pB).
  let pC#daaef59665fe2322d8ec3edfb3c8f635899cde8e3cd61a5e68051a6dd7e07443 : < ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (nab#pC)
  split nab#pC {na#pC, nb#pC}.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC)).
  let x#pC : Int = 42.
  let b#pB : Int = (x#pC + x#pC)

new_fused_ten2_Int_dbl =
  proc ()
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c : Session = (?Int).
  let ann#47d781f2688eff35434d58e35a537991b5fbfe16841a1609843ae641af58792b : Allocation = fused.
  let pA#37c1609f9609eee76ac190ff4a7e5594c6a82403dfb85e6c0da41cc24468d4c5 : < A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c#pA)
  c#pA <- 42).
  let pB#31ffa47257b7d93b8afeefbe1e750446b0cd9e04fc0e3b5e229556101a4b490b : < B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (d#pB)
  let b#pB : Int <- d#pB).
  let pC#daaef59665fe2322d8ec3edfb3c8f635899cde8e3cd61a5e68051a6dd7e07443 : < ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (nab#pC)
  split nab#pC {na#pC, nb#pC}.
  let x#pC : Int <- na#pC.
  nb#pC <- (x#pC + x#pC)).
  let x#pC : Int = 42.
  let b#pB : Int = (x#pC + x#pC)

new_ten2_Int_fwd =
  proc ()
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = (!Int).
  let B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c : Session = (?Int).
  let ann#995e1bf18f4248c09f1cf45162b1df0a7599134782b35033e43137c17c7b7790 : Allocation = (fuse 2).
  let pA#37c1609f9609eee76ac190ff4a7e5594c6a82403dfb85e6c0da41cc24468d4c5 : < A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a > = (proc (c#pA)
  c#pA <- 42).
  let pB#31ffa47257b7d93b8afeefbe1e750446b0cd9e04fc0e3b5e229556101a4b490b : < B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (d#pB)
  let b#pB : Int <- d#pB).
  let pC#d2b96815c21fe9cb6c54126a7ce0cca26cf91a880eca58337b7d596308f1adf2 : < ~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#ff463788bd40c59893d740b5312b9ed8028f951edec7df32aaf2d3c4b1371c9c > = (proc (nab#pC)
  split nab#pC {nab#0#pC : ?Int, nab#1#pC : !Int}.
  let x#nab#0#pC : Int <- nab#0#pC.
  nab#1#pC <- x#nab#0#pC).
  let x#nab#0#pC : Int = 42.
  new/alloc [a, nab#0#pC : [: :]].
  let b#pB : Int = x#nab#0#pC.
  new/alloc [nab#1#pC : [: :], b]

no_dead_lock_new_new =
  proc ()
  let x : Int = 5.
  let y : Int = x

no_dead_lock_new_new_v2 =
  proc ()
  let x : Int = 5.
  let y : Int = x

non_dependent_function_type : Int -> Int =
  \ (x : Int)-> x + 1

assert
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> B a0 -> Type
  =
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> (b : B a0)-> Type
  : Type

assert
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> < ?B a0 >
  =
  (A : Type)-> (a0 : A)-> (B : (a : A)-> Type)-> < ?(b : B a0)>
  : Type

some_type : Type =
  Int

some_value : some_type =
  42

assert
  (S : Session)-> (m : Int)-> (n : Int)-> < S ^ (m + n)>
  =
  (S : Session)-> (m : Int)-> (n : Int)-> < S ^ (n + m)>
  : Type

order_LR =
  proc ()
  let x : Int = 1.
  let y : Int = 2

order_RL =
  proc ()
  let y : Int = 2.
  let x : Int = 1

order_LR_fuse1 =
  proc ()
  let x : Int = 1.
  let y : Int = 2

order_RL_fuse1 =
  proc ()
  let y : Int = 2.
  let x : Int = 1

order_LR_fuse2 =
  proc ()
  let x : Int = 1.
  let y : Int = 2

order_RL_fuse2 =
  proc ()
  let y : Int = 2.
  let x : Int = 1

par0 =
  proc (c : {})
  split c {}

par1 =
  proc (c : {!Int})
  split c {d}.
  d <- 42

par2 =
  proc (c : {!Int, ?Int})
  split c {d, e}.
  let x : Int <- e.
  d <- x

par2mix =
  proc (c : {!Int, ?Int})
  split c {d, e}.
  let x : Int <- e.
  d <- 42

par4_seq_send3 =
  proc (a : {[: !Int, !Int :], !Int, !Int, !Int})
  split a {b, e, f, g}.
  split b [: c, d :].
  e <- 1.
  c <- 2.
  f <- 3.
  d <- 4.
  g <- 5

parallel_assoc_2tensor2_left =
  proc (cde : [[!Int, !Int],!Int])
  split cde [cd, e].
  split cd [c, d].
  c <- 1.
  d <- 2.
  e <- 3

parallel_assoc_2tensor2_right =
  proc (cde : [[!Int, !Int],!Int])
  split cde [cd, e].
  split cd [c, d].
  e <- 3.
  c <- 1.
  d <- 2

parallel_assoc_flat =
  proc (c : !Int, d : !Int, e : !Int)
  c <- 1.
  d <- 2.
  e <- 3

parallel_assoc_left =
  proc (c : !Int, d : !Int, e : !Int)
  c <- 1.
  d <- 2.
  e <- 3

parallel_assoc_right =
  proc (c : !Int, d : !Int, e : !Int)
  c <- 1.
  d <- 2.
  e <- 3

parallel_assoc_tensor3_flat =
  proc (cde : [!Int, !Int, !Int])
  split cde [c, d, e].
  c <- 1.
  d <- 2.
  e <- 3

parallel_assoc_tensor3_left =
  proc (cde : [!Int, !Int, !Int])
  split cde [c, d, e].
  c <- 1.
  d <- 2.
  e <- 3

parallel_assoc_tensor3_right =
  proc (cde : [!Int, !Int, !Int])
  split cde [c, d, e].
  c <- 1.
  d <- 2.
  e <- 3

parallel_tensor4_flat =
  proc (cd : [!Int, !Int],ef : [!Int, !Int])
  split cd [c, d].
  split ef [e, f].
  c <- 1.
  e <- 2.
  d <- 3.
  f <- 4

parallel_tensor4_v0 =
  proc (cd : [!Int, !Int],ef : [!Int, !Int])
  split cd [c, d].
  split ef [e, f].
  c <- 1.
  e <- 2.
  d <- 3.
  f <- 4

par_comm =
  \ (A : Session)-> \ (B : Session)-> proc (c : {[~ A, ~ B],{B, A}})
  split c {i, o}.
  split i [na, nb].
  split o {b, a}.
  ( fwd A (a, na)
  | fwd B (b, nb))

par_loli_ten_send =
  \ (S : Type)-> \ (T : Type)-> proc (c : {[?S, ?T],[!S, !T]})
  split c {i, o}.
  split i [rs, rt].
  split o [ss, st].
  ( let vs : S <- rs
  | let vt : T <- rt ).
  ( ss <- vs
  | st <- vt )

par_loli_ten_send_v2 =
  \ (S : Type)-> \ (T : Type)-> proc (c : {[?S, ?T],[!S, !T]})
  split c {i, o}.
  split i [rs, rt].
  ( let vs : S <- rs
  | let vt : T <- rt ).
  split o [ss, st].
  ( ss <- vs
  | st <- vt )

par_seq_back =
  proc (a : {[: !Int, !Int :], !Int})
  split a {b, e}.
  split b [: c, d :].
  c <- 2.
  d <- 3.
  e <- 1

par_seq_front =
  proc (a : {[: !Int, !Int :], !Int})
  split a {b, e}.
  split b [: c, d :].
  e <- 1.
  c <- 2.
  d <- 3

par_seq_middle =
  proc (a : {[: !Int, !Int :], !Int})
  split a {b, e}.
  split b [: c, d :].
  c <- 2.
  e <- 1.
  d <- 3

par_seq_send3 =
  proc (a : {[: !Int, !Int :], !Int.!Int.!Int})
  split a {b, e}.
  split b [: c, d :].
  e <- 1.
  c <- 2.
  e <- 3.
  d <- 4.
  e <- 5

par_ten1_ten1 =
  proc (c : {[?Int],[!Int]})
  split c {e, d}.
  split d [l].
  split e [h].
  let x : Int <- h.
  l <- x

par_ten_ten_v0 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  split c {e, d}.
  split d [k, l].
  split e [h, g].
  let x : Int <- h.
  k <- 1.
  let y : Int <- l.
  g <- 2

par_ten_ten_v1 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  split c {e, d}.
  split d [k, l].
  split e [h, g].
  let x : Int <- h.
  k <- 1.
  let y : Int <- l.
  g <- 2

par_ten_ten_v2 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  split c {e, d}.
  split d [k, l].
  split e [h, g].
  k <- 1.
  let x : Int <- h.
  let y : Int <- l.
  g <- 2

pattern_example_expanded =
  proc (abcde : [!Int, [: !Int, !Int :], {[!Int, !Int],{?Int, ?Int}}])
  split abcde [a, bc, de].
  split bc [: b, c :].
  split de {d, e}.
  a <- 1.
  b <- 2.
  split d [d#0 : !Int, d#1 : !Int].
  c <- 3.
  split e {e#0 : ?Int, e#1 : ?Int}.
  let x#e#0 : Int <- e#0.
  let x#e#1 : Int <- e#1.
  d#0 <- x#e#0.
  d#1 <- x#e#1

plug_compose =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (p : < A, B >)-> \ (q : < ~ B, C >)-> proc (a : A, c : C)
  new [b : B, b' : ~ B].
  ( @ p {a, b}
  | @ q {b', c})

flat_par' =
  \ (A : Session)-> \ (B : Session)-> \ (p : < A, B >)-> proc (a : A, b : B)
  new [ab : {A, B},nanb].
  ( @ p (ab)
  | split nanb [na, nb].
    ( fwd A (a, na)
    | fwd B (b, nb)))

bump_par' =
  \ (A : Session)-> \ (B : Session)-> \ (p : < A, B >)-> proc (ab : {A, B})
  split ab {a, b}.
  @ p {a, b}

plug_compose' =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (p : < A, B >)-> \ (q : < ~ B, C >)-> proc (a : A, c : C)
  new [b : B, b' : ~ B].
  ( @ p {a, b}
  | @ q {b', c})

plug_compose_par_par : (A : Session)-> (B : Session)-> (C : Session)-> (p : < A, B >)-> (q : < ~ B, C >)-> < A, C > =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (p : < A, B >)-> \ (q : < ~ B, C >)-> bump_par' A C (plug_compose' A B C (flat_par' A B p)(flat_par' (~ B)C q))

plug_send_recv =
  \ (p : < !Int, ?Int >)-> proc (c : !Int, d : ?Int)
  @ p {c, d}

_ =
  1

_ =
  2

_ =
  "Hello!"

assert
  16 % 33
  =
  16


assert
  30 + 2
  =
  32


assert
  86 - 22
  =
  64


assert
  4 * 32
  =
  128


assert
  512 / 2
  =
  256


assert
  pow 2 9
  =
  512


assert
  (16 % 3)==I 16
  =
  `false


assert
  (pow 2 9)==I 512
  =
  `true


assert
  3.03 +D 0.11000000000000032
  =
  3.14


assert
  3.28 -D 0.13999999999999968
  =
  3.14


assert
  6.28 *D 0.5
  =
  3.14


assert
  1.57 /D 0.5
  =
  3.14


assert
  powD 0.1 1.0e-3
  =
  0.9977000638225533


assert
  300000.0 *D 1.0e-5
  =
  3.0000000000000004


assert
  (300000.0 *D 1.0e-5)==D 3.0000000000000004
  =
  `true


assert
  (300000.0 *D 1.0e-5)==D 3.0
  =
  `false


assert
  Int2Double 42
  =
  42.0


assert
  (Int2Double 44)==D 42.0
  =
  `false


assert
  showInt 42
  =
  "42"


assert
  (showInt 42)==S "41"
  =
  `false


assert
  showDouble 3.14
  =
  "3.14"


assert
  (showDouble 3.14)==S "314"
  =
  `false


assert
  showChar 'a'
  =
  "'a'"


assert
  (showChar 'a')==S "'a'"
  =
  `true


assert
  showString "Hello \"World\"!"
  =
  "\"Hello \\\"World\\\"!\""


assert
  (showString "Hello \"World\"!")==S ""
  =
  `false


assert
  "Hello " ++S "World!"
  =
  "Hello World!"


assert
  let hello = "Hello " in
  let world = "Let!" in
  hello ++S world
  =
  "Hello Let!"


replicate =
  \ (A : Type)-> \ (n : Int)-> \ (x : A)-> proc (os : [!A ^ n])
  split os [o ^ n].
  parallel ^ n
    o <- x

replicate_par =
  proc (c : {!Int ^ 10})
  split c {d ^ 10}.
  sequence ^ 10 with i
    d <- i

replicate_proc =
  \ (A : Type)-> \ (n : Int)-> proc (c : {?A, [!A ^ n]})
  split c {i, os}.
  let x : A <- i.
  split os [o ^ n].
  parallel ^ n
    o <- x

replicate_proc_Int_10 =
  let A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 : Type = Int in
  let n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd : Int = 10 in
  proc (c : {?A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2, [!A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 ^ n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd]})
  split c {i, os}.
  let x : A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 <- i.
  split os [o ^ n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd].
  sequence ^ n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd
    o <- x

tabulate_ten =
  \ (A : Type)-> \ (f : (i : Int)-> A)-> \ (n : Int)-> proc (c : [!A ^ n])
  split c [c_ ^ n].
  parallel ^ n with i
    c_ <- (f i)

replicate_ten_10 =
  let A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 : Type = Int in
  let f#a5d515deb50c9a55bc22b1fe4da48cf445a7abd6b81d0913b1829ace4d53bbff : (i#f : Int)-> A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 = id Int in
  let n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd : Int = 10 in
  proc (c : [!A#2d0382a85cd5a47852d1b3bb6ae425877166868333e37ddc334687f16d39abc2 ^ n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd])
  split c [c_ ^ n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd].
  sequence ^ n#8b6bdcd17d3f6de80744efcc6aed2afd586ac1c1b6904bad50440163d9320ddd with i
    c_ <- (f#a5d515deb50c9a55bc22b1fe4da48cf445a7abd6b81d0913b1829ace4d53bbff i)

Int1 =
  Int

send_1 =
  proc (c : !Int1)
  c <- 1

seq0_explicit =
  proc (c : [: :])
  split c [: :]

seq0 =
  proc (c : [: :])
  ( )

seq3 =
  proc (c : [: !Int, !Int, !Int :])
  split c [: c0, c1, c2 :].
  c0 <- 0.
  c1 <- 1.
  c2 <- 2

seq3_seq2 =
  proc (c : [: !Int, !Int, !Int :], d : [: !Int, !Int :])
  split c [: c0, c1, c2 :].
  split d [: d0, d1 :].
  c0 <- 0.
  c1 <- 1.
  d0 <- 0.
  c2 <- 2.
  d1 <- 1

seq_assoc_core =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> proc (i : [: [: ~ A, ~ B :], ~ C :], o : [: A, [: B, C :] :])
  split i [: nab, nc :].
  split nab [: na, nb :].
  split o [: a, bc :].
  split bc [: b, c :].
  fwd A (a, na).
  fwd B (b, nb).
  fwd C (c, nc)

seq_par_back =
  proc (a : [: {!Int, !Int},!Int :])
  split a [: b, e :].
  split b {c, d}.
  c <- 2.
  d <- 3.
  e <- 1

seq_par_back_v2 =
  proc (a : [: {!Int, !Int},!Int :])
  split a [: b, e :].
  split b {c, d}.
  d <- 3.
  c <- 2.
  e <- 1

seq_seq =
  proc (a : [: [: !Int, !Int :], !Int :])
  split a [: b, e :].
  split b [: c, d :].
  c <- 1.
  d <- 2.
  e <- 3

seq_seq_send2 =
  proc (a : [: [: !Int.!Int, !Int.!Int :], !Int.!Int :])
  split a [: b, e :].
  split b [: c, d :].
  c <- 1.
  c <- 2.
  d <- 3.
  d <- 4.
  e <- 5.
  e <- 6

seq_ten =
  proc (a : [: [!Int, !Int],!Int :])
  split a [: b, e :].
  split b [c, d].
  c <- 2.
  d <- 3.
  e <- 1

singleRecv =
  proc (c : ?Int)
  let x : Int <- c

singleSend =
  proc (c : !Int)
  c <- 42

sorter =
  \ (n : Int)-> proc (c : {?Vec Int n, !Vec Int n})
  split c {ci, co}.
  let v : Vec Int n <- ci.
  co <- (sort n v)

split_fwd1_rcv =
  proc (c : {?Int})
  split c {d}.
  let x#d : Int <- d

split_nested_seq : (A : Session)-> (B : Session)-> (C : Session)-> (D : Session)-> < [: ~ A, ~ B, ~ C, ~ D :], [: [: A, B :], [: C, D :] :] > =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> \ (D : Session)-> proc (c : {[: ~ A, ~ B, ~ C, ~ D :], [: [: A, B :], [: C, D :] :]})
  split c {i, o}.
  split i [: na, nb, nc, nd :].
  split o [: ab, cd :].
  split ab [: a, b :].
  split cd [: c, d :].
  fwd A (a, na).
  fwd B (b, nb).
  fwd C (c, nc).
  fwd D (d, nd)

sum_int =
  proc (a : {?Int ^ 10},r : !Int)
  new/alloc (acc :* Int).
  acc <- 0.
  split acc [: acci ^ 10, accn :].
  split a {ai ^ 10}.
  (sequence ^ 10 with i
    (let x : Int <- ai.
    let y : Int <- acci.
    acci <- (x + y)) ).
  let x#accn : Int <- accn.
  r <- x#accn

switch : (A : Session)-> (B : Session)-> (C : Session)-> < {~ A, [~ B, ~ C]}, {[A, B],C}> =
  \ (A : Session)-> \ (B : Session)-> \ (C : Session)-> proc (c : {{~ A, [~ B, ~ C]}, {[A, B],C}})
  split c {i, o}.
  split i {na, nbc}.
  split nbc [nb, nc].
  split o {ab, c}.
  split ab [a, b].
  ( fwd A (a, na)
  | fwd B (b, nb)
  | fwd C (c, nc))

ten_loli_par =
  \ (A : Session)-> \ (B : Session)-> proc (c : {{~ A, ~ B},{A, B}})
  split c {i, o}.
  split i {na, nb}.
  split o {a, b}.
  ( fwd A (a, na)
  | fwd B (b, nb))

ten_loli_par_sInt_sDouble =
  let A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a : Session = !Int in
  let B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d : Session = !Double in
  proc (c : {{~ A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, ~ B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d},{A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a, B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d}})
  split c {i, o}.
  split i {na, nb}.
  split o {a, b}.
  fwd A#58c563cde134cc361a5d925c1e3848fb7ba1be21e1117171a7cb77110e8d4c2a (a, na).
  fwd B#939cb0dd307d57a11f4fb89ad265ebfb39055bd9d48dec800b4e900e08472a0d (b, nb)

ten_loli_par_sequential =
  \ (A : Session)-> \ (B : Session)-> proc (c : {{~ A, ~ B},{A, B}})
  split c {i, o}.
  split i {na, nb}.
  split o {a, b}.
  fwd A (a, na).
  fwd B (b, nb)

ten_par_par_split =
  proc (c : [{}, {}])
  split c [d, e].
  split d {}.
  split e {}

tensor0 =
  proc (c : [])
  split c []

tensor1 =
  proc (c : [!Int])
  split c [d].
  d <- 42

tensor2 =
  proc (c : [!Int, ?Int])
  split c [d, e].
  let x : Int <- e.
  d <- 42

tensor2_tensor0_tensor0_parallel =
  proc (cd : [[], []])
  split cd [c, d].
  split c [].
  split d []

tensor2_tensor0_tensor0_sequence =
  proc (cd : [[], []])
  split cd [c, d].
  split c [].
  split d []

tensor2_using_dual =
  proc (c : [!Int, ?Int])
  split c [d, e].
  let x : Int <- e.
  d <- 42

test2 =
  proc ()
  let x0 : Int = 1.
  let z0 : Int = (x0 + 1).
  let x1 : Int = (z0 + 5).
  let y0 : Int = (x1 + x0 + 2).
  let x2 : Int = (y0 + 4).
  let z1 : Int = (x2 + x1 + x0 + 3)

test3 =
  proc ()
  let x0 : Int = 1.
  let y0 : Int = x0.
  let z0 : Int = x0

type_annotation =
  (21 + 21 : Int)

ZeroCh : Type =
  (A : Type)-> A

One : Type =
  (A : Type)-> (x : A)-> A

zeroOne : One =
  \ (A : Type)-> \ (x : A)-> x

Two : Type =
  (A : Type)-> (x : A)-> (y : A)-> A

zeroTwo : Two =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> x

oneTwo : Two =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> y

notTwo : (b : Two)-> Two =
  \ (b : Two)-> \ (A : Type)-> \ (x : A)-> \ (y : A)-> b A y x

notZero : Two =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> let A' = A in
  let x' = y in
  let y' = x in
  x'

notZero' : Two =
  let b = zeroTwo in
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> b A y x

notZero'' : Two =
  notTwo zeroTwo

assert
  notTwo zeroTwo
  =
  oneTwo
  : Two

assert
  notTwo oneTwo
  =
  zeroTwo
  : Two

andTwo : (b0 : Two)-> (b1 : Two)-> Two =
  \ (b0 : Two)-> \ (b1 : Two)-> b0 Two zeroTwo b1

assert
  andTwo zeroTwo zeroTwo
  =
  zeroTwo
  : Two

assert
  andTwo zeroTwo oneTwo
  =
  zeroTwo
  : Two

assert
  andTwo oneTwo zeroTwo
  =
  zeroTwo
  : Two

assert
  andTwo oneTwo oneTwo
  =
  oneTwo
  : Two

orTwo : (b0 : Two)-> (b1 : Two)-> Two =
  \ (b0 : Two)-> \ (b1 : Two)-> b0 Two b1 oneTwo

assert
  orTwo zeroTwo zeroTwo
  =
  zeroTwo
  : Two

assert
  orTwo zeroTwo oneTwo
  =
  oneTwo
  : Two

assert
  orTwo oneTwo zeroTwo
  =
  oneTwo
  : Two

assert
  orTwo oneTwo oneTwo
  =
  oneTwo
  : Two

Nat : Type =
  (A : Type)-> (z : A)-> (s : (n : A)-> A)-> A

zeroNat : Nat =
  \ (A : Type)-> \ (z : A)-> \ (s : (n : A)-> A)-> z

sucNat : (n : Nat)-> Nat =
  \ (n : Nat)-> \ (A : Type)-> \ (z : A)-> \ (s : (m : A)-> A)-> s (n A z s)

oneNat : Nat =
  sucNat zeroNat

twoNat : Nat =
  sucNat oneNat

threeNat : Nat =
  sucNat twoNat

fourNat : Nat =
  sucNat threeNat

fiveNat : Nat =
  sucNat fourNat

sixNat : Nat =
  sucNat fiveNat

addNat : (m : Nat)-> (n : Nat)-> Nat =
  \ (m : Nat)-> \ (n : Nat)-> m Nat n sucNat

assert
  addNat zeroNat oneNat
  =
  oneNat
  : Nat

assert
  addNat oneNat zeroNat
  =
  oneNat
  : Nat

assert
  addNat twoNat threeNat
  =
  fiveNat
  : Nat

mulNat : (m : Nat)-> (n : Nat)-> Nat =
  \ (m : Nat)-> \ (n : Nat)-> m Nat zeroNat (addNat n)

assert
  mulNat zeroNat oneNat
  =
  zeroNat
  : Nat

assert
  mulNat oneNat zeroNat
  =
  zeroNat
  : Nat

assert
  mulNat oneNat oneNat
  =
  oneNat
  : Nat

assert
  mulNat oneNat oneNat
  =
  addNat oneNat zeroNat
  : Nat

assert
  mulNat twoNat threeNat
  =
  addNat threeNat (addNat threeNat zeroNat)
  : Nat

assert
  mulNat twoNat threeNat
  =
  sixNat
  : Nat

Bin : Type =
  (A : Type)-> (leaf : A)-> (fork : (left : A)-> (right : A)-> A)-> A

Nats : Type =
  (A : Type)-> (nil : A)-> (cons : (head : Nat)-> (tail : A)-> A)-> A

List : (X : Type)-> Type =
  \ (X : Type)-> (A : Type)-> (nil : A)-> (cons : (head : X)-> (tail : A)-> A)-> A

nilList : (X : Type)-> List X =
  \ (X : Type)-> \ (A : Type)-> \ (nil : A)-> \ (cons : (head : X)-> (tail : A)-> A)-> nil

consList : (X : Type)-> (head : X)-> (tail : List X)-> List X =
  \ (X : Type)-> \ (head : X)-> \ (tail : List X)-> \ (A : Type)-> \ (nil : A)-> \ (cons : (head' : X)-> (tail' : A)-> A)-> cons head (tail A nil cons)

mapList : (X : Type)-> (Y : Type)-> (f : (x : X)-> Y)-> (xs : List X)-> List Y =
  \ (X : Type)-> \ (Y : Type)-> \ (f : (x : X)-> Y)-> \ (xs : List X)-> \ (A : Type)-> \ (nil : A)-> \ (cons : (head' : Y)-> (tail' : A)-> A)-> xs A nil (\ (head : X)-> \ (tail : A)-> cons (f head)tail)

Id : (A : Type)-> (x : A)-> (y : A)-> Type

refl : (A : Type)-> (x : A)-> Id A x x

J : (A : Type)-> (x : A)-> (P : (y : A)-> (p : Id A x y)-> Type)-> (Px : P x (refl A x)) -> (y : A)-> (p : Id A x y)-> P y p

J-refl : (A : Type)-> (x : A)-> (P : (y : A)-> (p : Id A x y)-> Type)-> (Px : P x (refl A x)) -> Id (P x (refl A x)) (J A x P Px x (refl A x)) Px

tr : (A : Type)-> (x : A)-> (P : (y : A)-> Type)-> (Px : P x)-> (y : A)-> (p : Id A x y)-> P y =
  \ (A : Type)-> \ (x : A)-> \ (P : (y : A)-> Type)-> \ (Px : P x)-> \ (y : A)-> \ (p : Id A x y)-> J A x (\ (z : A)-> \ (q : Id A x z)-> P z)Px y p

tr-refl : (A : Type)-> (x : A)-> (P : (y : A)-> Type)-> (Px : P x)-> Id (P x)(tr A x P Px x (refl A x)) Px =
  \ (A : Type)-> \ (x : A)-> \ (P : (y : A)-> Type)-> \ (Px : P x)-> J-refl A x (\ (z : A)-> \ (q : Id A x z)-> P z)Px

coe : (A : Type)-> (B : Type)-> (p : Id Type A B)-> (x : A)-> B =
  \ (A : Type)-> \ (B : Type)-> \ (p : Id Type A B)-> \ (x : A)-> tr Type A (\ (X : Type)-> X)x B p

coe-refl : (A : Type)-> (x : A)-> Id A (coe A A (refl Type A)x)x =
  \ (A : Type)-> \ (x : A)-> tr-refl Type A (\ (X : Type)-> X)x

sym : (A : Type)-> (x : A)-> (y : A)-> (p : Id A x y)-> Id A y x =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> \ (p : Id A x y)-> tr A x (\ (z : A)-> Id A z x)(refl A x)y p

trans : (A : Type)-> (x : A)-> (y : A)-> (z : A)-> (p : Id A x y)-> (q : Id A y z)-> Id A x z =
  \ (A : Type)-> \ (x : A)-> \ (y : A)-> \ (z : A)-> \ (p : Id A x y)-> \ (q : Id A y z)-> tr A y (Id A x)p z q

uncurry =
  \ (S : Session)-> \ (T : Session)-> \ (U : Session)-> proc (c : {[S, [T, ~ U]], {{~ S, ~ T},U}})
  split c {f, xyo}.
  split xyo {xy, o}.
  split xy {x, y}.
  split f [fx, fyo].
  split fyo [fy, fo].
  ( fwd S (fx, x)
  | fwd T (fy, y)
  | fwd U (o, fo))

zap =
  \ (S : Session)-> \ (T : Session)-> \ (n : Int)-> proc (c : {{[S, ~ T]^ n},{{~ S ^ n},[T ^ n]}})
  split c {fs, xos}.
  split xos {xs, os}.
  split fs {f ^ n}.
  split xs {x ^ n}.
  split os [o ^ n].
  parallel ^ n
    (split f [fi, fo].
    ( fwd S (fi, x)
    | fwd T (o, fo)))

zap_ten_fwd =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  split cf {cfi ^ 10}.
  split cn {cni ^ 10}.
  split co [coi ^ 10].
  sequence ^ 10
    (split cfi {cfii, cfio}.
    let x#cni : Int <- cni.
    let x#cfio : Int <- cfio.
    cfii <- x#cni.
    coi <- x#cfio)

zap_ten_par =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  split cf {cfi ^ 10}.
  split cn {cni ^ 10}.
  split co [coi ^ 10].
  sequence ^ 10
    (split cfi {cfii, cfio}.
    let x : Int <- cni.
    let y : Int <- cfio.
    cfii <- x.
    coi <- y)

zap_ten_seq =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  split cf {cfi ^ 10}.
  split cn {cni ^ 10}.
  split co [coi ^ 10].
  sequence ^ 10
    (split cfi {cfii, cfio}.
    let x : Int <- cni.
    cfii <- x.
    let y : Int <- cfio.
    coi <- y)

zip_add =
  proc (xs : {?Int ^ 10},ys : {?Int ^ 10},zs : [!Int ^ 10])
  split xs {x ^ 10}.
  split ys {y ^ 10}.
  split zs [z ^ 10].
  sequence ^ 10
    (let a : Int <- x.
    let b : Int <- y.
    z <- (a + b))
